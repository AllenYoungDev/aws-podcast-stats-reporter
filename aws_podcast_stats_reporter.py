###############################################################################
#Copyright AD 2020 Allen Young,
#all rights reserved.  AllenYoung.dev
#
#Authored by Allen Young, the transhumanistic Asian-American man who  
#promotes and advances the science, technology, and capitalism of 
#artificial intelligence, robotics, human longevity biotech, 
#human genetic engineering, and outer-space humanity expansion.
#
#For more information about Allen Young and his scientific,
#technological and capitalistic ventures for revolutionizing humankind,
#visit Robocentric.com.
#
#
#DISCLAIMER
#This computer code is provided as is.
#Allen Young makes no guarantee and
#assumes no responsibility in the use of this computer code.
###############################################################################


###############################################################################
#------------------------------------------------------------------------------
#How This Software Program Behaves
#------------------------------------------------------------------------------
###############################################################################
"""
What this software program does
===============================
This software program processes the podcast-log AWS S3 objects that are
generated by AWS, to automatically generate and save
podcast-stats AWS S3 objects.

If emailing settings are on, this software program will email
daily, weekly, and/or monthly podcast stats to the designated email address,
if there are stats to email when this program is run (i.e.
if no podcast episode download stats, no email).

When INCLUDE_NUMBERS_OF_RETRIES_IN_PODCAST_STATS_EMAILS setting is set to True,
the numbers of the AWS operation retries will be included in each email.
When there's no AWS operation error, the numbers of retries should be all zero.
This feature is supported for reporting the operational health of AWS.

When all of the podcast-log AWS S3 object deletion settings are set to True,
this software auto-deletes every irrelevant and outdated podcast-log AWS S3
object, after emailing and saving podcast stats.  Turning off the podcast-log
deletion settings is for debugging purposes only; they should be all on in
normal operation.  The podcast-log AWS S3 objects should not be deleted by
other means.


When to execute this software program
=====================================
This software program should be auto-executed everyday, at least several hours 
after midnight in the UTC time zone (which is the time zone used in AWS S3).
4am or 5am UTC is a good choice to auto-execute this program at.


Environment variable to set for program settings
================================================
PODCAST_NAMES_IN_STATS_REPORTS
------------------------------
A comma-separated list of podcast names to use in podcast-stats reports.
Each bucket name must be single or double quoted.
This environment variable must be defined.
Redundant entries are not allowed, since each podcast name should be unique.

PODCAST_EPISODE_AWS_S3_BUCKET_FOLDER_PATHS
------------------------------------------
A comma-separated list of podcast-episode AWS S3 bucket folder paths.
Each bucket folder path must be single or double quoted.
This environment variable must be defined.
Each AWS S3 bucket folder path starts with the bucket name,
then continues with folder names with / as separator between names.
An AWS S3 bucket folder path may end with /.
It is ok to specify just the bucket name with or without the trailing /
(i.e to indicate the root folder).
This input parameter is required, for the purpose of associating each podcast
name to the podcast-episode AWS S3 folder paths, for the purpose of reporting
podcast-episode download statistics.
Redundant entries are not allowed: each entry must be unique.

PODCAST_LOG_AWS_S3_BUCKET_FOLDER_PATHS
--------------------------------------
A comma-separated list of podcast-log AWS S3 bucket folder paths.
Each bucket folder path must be single or double quoted.
This environment variable must be defined.
Each AWS S3 bucket folder path starts with the bucket name,
then continues with folder names with / as separator between names.
An AWS S3 bucket folder path may end with /.
It is ok to specify just the bucket name with or without the trailing /
(i.e to indicate the root folder).
This input parameter specifies the paths of the AWS S3 bucket folders that
contain the podcast logs to process.
Specifying an AWS S3 bucket only will process all the objects in all the
folders of that bucket.
Specifying an AWS S3 bucket folder path will process all the objects in that
folder only, not in its sub-folders.
The podcast-log AWS S3 bucket folder paths passed to this function
must not result in redundant podcast log processing.  That is, 
each entry must be unique, because each log AWS S3 bucket folder should be
processed only once; moreover, when AWS S3 bucket folder path is specified,
its AWS S3 bucket name must not be specified, vice versa, to avoid
processing the AWS S3 objects in the AWS S3 bucket folder more than once.

PODCAST_STATS_AWS_S3_BUCKET_FOLDER_PATHS
----------------------------------------
A comma-separated list of podcast-stats AWS S3 bucket folder paths.
Each bucket folder path must be single or double quoted.
This environment variable must be defined.
Each AWS S3 bucket folder path starts with the bucket name,
then continues with folder names with / as separator between names.
An AWS S3 bucket folder path may end with /.
It is ok to specify just the bucket name with or without the trailing /
(i.e to indicate the root folder).
Redundant entries are allowed, since this software allows storing podcast stats
of more than one podcast in a single AWS S3 bucket folder.
Each podcast-stat AWS S3 object name has the podcast-episode AWS S3 folder path
with / replaced with _, a space, and the date range (YYYY-MM-DD if day stats,
or starting YYYY-MM-DD, a space, ending YYYY-MM-DD, if week or month stats).

The numbers of the podcast names, the podcast-episode AWS S3 bucket folder
paths, and podcast-stats AWS S3 bucket folder paths must match, while
the number of the podcast-log AWS S3 bucket folder paths must be equal to, or
smaller than the number of the podcast-episode AWS S3 bucket folder paths, and
greater than zero.

Each specified AWS S3 bucket must contain only one type of data
(podcast episode, podcast logs, or podcast stats).
That is, if an AWS S3 bucket is included in
PODCAST_EPISODE_AWS_S3_BUCKET_FOLDER_PATHS,
PODCAST_LOG_AWS_S3_BUCKET_FOLDER_PATHS, or
PODCAST_STATS_AWS_S3_BUCKET_FOLDER_PATHS, then it must not be included in
any of the other two path lists.
During the input parameters validation, this software enforces
the single-type (not multi-type) usage of podcast AWS S3 buckets.


FIRST_COLUMN_DATA_TYPE_IN_EMAIL
-------------------------------
Defining this environment variable is optional.
The value of this environment variable must be set to either 'count' or 'name'
(no quotation marks, case-insensitive).
If this environment variable is not defined, or set to "count",
the first column in emails will contain podcast-episode download counts.
If this environment variable is set to "name",
the first column in emails will contain podcast-episode names.
The podcast-stats AWS S3 object content will always have
the podcast-episode name in the first column, and
the podcast-episode download count in the second column,
with each column separated by the tab (\t) character.

PODCAST_STATS_SENDER_EMAIL_ADDRESS
----------------------------------
The email address of the podcast-stats emails sender.
The email address must NOT be single or double quoted.
This environment variable must be defined.
This email address or domain must be already verified on AWS SES.

PODCAST_STATS_SENDER_NAME
-------------------------
Defining this environment variable is optional.
This is the name of the podcast-stats report sender in each email.
The value of this environment variable does not need to be single or double
quoted; the exact environment variable value will be used as the sender name.
If this environment variable is not defined, the default value of 
"Podcast Reports" (no quotation marks, case-sensitive) will be used.

PODCAST_STATS_RECIPIENT_EMAIL_ADDRESS
-------------------------------------
The email address of the podcast-stats emails recipient.
The email address must NOT be single or double quoted.
This environment variable must be defined.

DAILY_PODCAST_STATS_EMAIL
-------------------------
Defining this environment variable is optional.
The value of this environment variable must be set to either "True" or "False"
(no quotation marks, correct capitalization required).
If this environment variable is not defined, daily podcast emails will be sent.

WEEKLY_PODCAST_STATS_EMAIL
--------------------------
Defining this environment variable is optional.
The value of this environment variable must be set to either "True" or "False"
(no quotation marks, correct capitalization required).
If this environment variable is not defined, weekly podcast emails will be
sent.

MONTHLY_PODCAST_STATS_EMAIL
---------------------------
Defining this environment variable is optional.
The value of this environment variable must be set to either "True" or "False"
(no quotation marks, correct capitalization required).
If this environment variable is not defined, monthly podcast emails will be 
sent.

INCLUDE_NUMBERS_OF_RETRIES_IN_PODCAST_STATS_EMAILS
--------------------------------------------------
Defining this environment variable is optional.
The value of this environment variable must be set to either "True" or "False"
(no quotation marks, correct capitalization required).
If this environment variable is not defined, or set to "False", the numbers of 
the AWS operation retries will not be included in each email.  when there's no 
AWS operation error, the numbers of retries should be all zero.
This feature is available for reporting the operational health of AWS.


SEPARATE_PODCAST_STATS_EMAILS
-----------------------------
Defining this environment variable is optional.
The value of this environment variable must be set to either "True" or "False"
(no quotation marks, correct capitalization required).
If this environment variable is not defined, or set to False,
each email will contain daily, weekly, or monthly podcast stats for
all the specified podcasts (with podcast names and podcast-episode AWS S3
bucket folder paths).
If this environment variable is set to True,
each email will contain daily, weekly, or monthly podcast stats for
only one specified podcast.
That is, this setting is for specifying and controlling the number of
podcasts that the download stats are reported on, in each email.


PODCAST_STATS_HTML_EMAIL_BACKDROP_COLOR
---------------------------------------
Defining this environment variable is optional.
The value of this environment variable must be in the form of "rgb(#,#,#)"
(no quotation marks, case-insensitive, each # should be an integer number
between 0 and 255, the first # is the red component,
the second # is the green component, and the third # is the blue component).
"_default_" (no quotation marks, case-insensitive) is also a supported value.
If this environment variable is not defined, it is assumed to be
"_default_", which results in assigning no backdrop color, hence using
the system default backdrop color.

PODCAST_STATS_HTML_EMAIL_SECTION_HEADING_BACKDROP_COLOR
-------------------------------------------------------
Defining this environment variable is optional.
The value of this environment variable must be in the form of "rgb(#,#,#)"
(no quotation marks, case-insensitive, each # should be an integer number
between 0 and 255, the first # is the red component,
the second # is the green component, and the third # is the blue component).
"_default_" (no quotation marks, case-insensitive) is also a supported value,
which results in assigning no backdrop color, hence using the system default 
backdrop color.
If this environment variable is not defined, it is assumed to be "rgb(0,0,100)"
(no quotation marks, case-insensitive), which is dark blue.

PODCAST_STATS_HTML_EMAIL_SECTION_HEADING_FONT_NAME
--------------------------------------------------
Defining this environment variable is optional.
The value of this environment variable must be the name of the font to use,
or "_default_" (without the quotation marks, case-insensitive).
If this environment variable is not defined, or set to "_default_" (without
the quotation marks, case-insensitive), no font name will be specified
in each HTML email section heading, hence the default font will be used
in the email client software program.

PODCAST_STATS_HTML_EMAIL_SECTION_HEADING_FONT_SIZE
--------------------------------------------------
Defining this environment variable is optional.
The value of this environment variable must be an integer or decimal number
with an HTML CSS font-size unit (px, %, em, pt, etc.).
"_default_" (no quotation marks, case-insensitive) is also a supported value.
If this environment variable is not defined, it is assumed to be
"_default_", which results in assigning no font size, hence using
the system default font size.

PODCAST_STATS_HTML_EMAIL_SECTION_HEADING_FONT_COLOR
---------------------------------------------------
Defining this environment variable is optional.
The value of this environment variable must be in the form of "rgb(#,#,#)"
(no quotation marks, case-insensitive, each # should be an integer number
between 0 and 255, the first # is the red component,
the second # is the green component, and the third # is the blue component).
"_default_" (no quotation marks, case-insensitive) is also a supported value,
which results in assigning no font color, hence using the system default 
font color.
If this environment variable is not defined, it is assumed to be
"rgb(255,255,255)" (no quotation marks, case-insensitive), which is pure white.

PODCAST_STATS_HTML_EMAIL_BODY_FONT_NAME
---------------------------------------
Defining this environment variable is optional.
The value of this environment variable must be the name of the font to use,
or "_default_" (without the quotation marks, case-insensitive).
If this environment variable is not defined, or set to "_default_" (without
the quotation marks, case-insensitive), no font name will be specified
in each HTML email body paragraph, hence the default font will be used
in the email client software program.

PODCAST_STATS_HTML_EMAIL_BODY_FONT_SIZE
---------------------------------------
Defining this environment variable is optional.
The value of this environment variable must be an integer or decimal number
with an HTML CSS font-size unit (px, %, em, pt, etc.).
"_default_" (no quotation marks, case-insensitive) is also a supported value.
If this environment variable is not defined, it is assumed to be
"_default_", which results in assigning no font size, hence using
the system default font size.

PODCAST_STATS_HTML_EMAIL_BODY_FONT_COLOR
----------------------------------------
Defining this environment variable is optional.
The value of this environment variable must be in the form of "rgb(#,#,#)"
(no quotation marks, case-insensitive, each # should be an integer number
between 0 and 255, the first # is the red component,
The second # is the green component, and the third # is the blue component).
"_default_" (no quotation marks, case-insensitive) is also a supported value.
If this environment variable is not defined, it is assumed to be
"_default_", which results in assigning no font color, hence using
the system default font color.


This software classifies podcast-log AWS S3 objects in three ways.
A non-download-entry podcast log contains one or more of log entries that do
not indicate download of any sort, and hence is not used in building podcast
download statistics.
An irrelevant-download-entry podcast log contains one or more of log entries
that indicate one or more downloads of one or more AWS S3 objects that aren't
in one of the AWS S3 bucket folders indicated in
PODCAST_EPISODE_AWS_S3_BUCKET_FOLDER_PATHS, and hence is not used in building
podcast download statistics.
An relevant-download-entry podcast log contains one or more of log entries
that indicate one or more downloads of one or more AWS S3 objects that are in
one or more of the AWS S3 bucket folders indicated in
PODCAST_EPISODE_AWS_S3_BUCKET_FOLDER_PATHS, and hence is used in building
podcast download statistics.
According to the above classification system, a podcast-log AWS S3 object can
be any combination of the above podcast-log types.
The above classification system is used for podcast-log deletion and software
debugging purposes.  For optimal operation and minimization of AWS cost,
this software should auto-delete the irrelevant and outdated podcast-log AWS S3
objects; this software auto-deletes podcast logs according to the settings
specificed below.  Under normal operation, every type of podcast log must be
set for auto-deletion; podcast log auto-deletion should be turned off, only for
software development and debugging purposes.

NON_DOWNLOAD_ENTRY_PODCAST_LOG_AWS_S3_BUCKET_OBJECTS_DELETION
-------------------------------------------------------------
Defining this environment variable is optional.
The value of this environment variable must be set to either "True" or "False"
(no quotation marks, correct capitalization required).
If this environment variable is not defined, or set to True, this software,
after sending email(s) and storing podcast-stats AWS S3 bucket object(s),
will delete each podcast-log AWS S3 object in the locations specified by
PODCAST_LOG_AWS_S3_BUCKET_FOLDER_PATHS, if the log contains only the
non-download entries, or all the download entries in the log are marked for
deletion also by other settings below.
If this environment variable is set to False, this program does not delete
all the processed podcast-log AWS S3 bucket objects, that are in the locations
specified by PODCAST_LOG_AWS_S3_BUCKET_FOLDER_PATHS, and contain one or more
non-download entries.  The non-deleted podcast logs would be processed again
when this program is run again, and hence (unnecessary) AWS cloud computing
costs would incur.
This option is available for debugging purposes.
Under normal use, this setting should be set to True.

IRRELEVANT_DOWNLOAD_ENTRY_PODCAST_LOG_AWS_S3_BUCKET_OBJECTS_DELETION
--------------------------------------------------------------------
Defining this environment variable is optional.
The value of this environment variable must be set to either "True" or "False"
(no quotation marks, correct capitalization required).
If this environment variable is not defined, or set to True, this software,
after sending email(s) and storing podcast-stats AWS S3 bucket object(s),
will delete each podcast-log AWS S3 object in locations specified by
PODCAST_LOG_AWS_S3_BUCKET_FOLDER_PATHS, if the log contains only the
irrelevant-download entries, or all the other types of entries in the log
are set for deletion also by the other two podcast-log deletion settings.
If this environment variable is set to False, this program does not delete
all the processed podcast-log AWS S3 bucket objects, that are in the locations
specified by PODCAST_LOG_AWS_S3_BUCKET_FOLDER_PATHS, and contain one or more
irrelevant-download entries.  Those podcast logs would be processed again
when this program is run again, and hence (unnecessary) AWS cloud computing
costs would incur.
This option is available for debugging purposes.
Under normal use, this setting should be set to True.

RELEVANT_DOWNLOAD_ENTRY_PODCAST_LOG_AWS_S3_BUCKET_OBJECTS_DELETION
------------------------------------------------------------------
Defining this environment variable is optional.
The value of this environment variable must be set to either "True" or "False"
(no quotation marks, correct capitalization required).
If this environment variable is not defined, or set to True, this software,
after sending email(s) and storing podcast-stats AWS S3 bucket object(s),
will delete each podcast-log AWS S3 object in locations specified by
PODCAST_LOG_AWS_S3_BUCKET_FOLDER_PATHS, if the log contains only the
relevant-download entries, or all the other types of entries in the log
are set for deletion also by the other two podcast-log deletion settings.
If this environment variable is set to False, this program does not delete
all the processed podcast-log AWS S3 bucket objects, that are in the locations
specified by PODCAST_LOG_AWS_S3_BUCKET_FOLDER_PATHS, and contain one or more
relevant-download entries.  Those podcast logs would be processed again
when this program is run again, and hence (unnecessary) AWS cloud computing
costs would incur.
This option is available for debugging purposes.
Under normal use, this setting should be set to True.

When all of the above three settings are set to true, this software
auto-deletes every irrelevant and outdated podcast-log AWS S3 object,
after emailing and saving podcast stat(s).


PODCAST_STATS_REPORT_LANGUAGE
-----------------------------
Defining this environment variable is optional.
This program setting specifies the language to be used in the podcast-stat
reports.  Currently, only "English" (no quotation marks, case-sensitive) is
supported.
If this value is not defined, or set to "English", the language in the
podcast-stats reports will be in English.


Command parameters format
=========================
If you're running this software program in a terminal (on Linux, Mac,
or Windows), not as an AWS Lambda function, then you can provide
program settings as the command parameters.

If all the command parameters are provided, then this program will
use the command parameters for the program settings, instead of using
the environment variables.

The command parameters should be provided in the following format.

python.exe aws_podcast_stats_reporter.py "PODCAST_NAMES_IN_STATS_REPORTS" \
"PODCAST_EPISODE_AWS_S3_BUCKET_FOLDER_PATHS" \
"PODCAST_LOG_AWS_S3_BUCKET_FOLDER_PATHS" \
"PODCAST_STATS_AWS_S3_BUCKET_FOLDER_PATHS" \
"FIRST_COLUMN_DATA_TYPE_IN_EMAIL" \
"PODCAST_STATS_SENDER_EMAIL_ADDRESS" \
"PODCAST_STATS_RECIPIENT_EMAIL_ADDRESS" \
"DAILY_PODCAST_STATS_EMAIL" "WEEKLY_PODCAST_STATS_EMAIL" \
"MONTHLY_PODCAST_STATS_EMAIL" \
"INCLUDE_NUMBERS_OF_RETRIES_IN_PODCAST_STATS_EMAILS" \
"SEPARATE_PODCAST_STATS_EMAILS" \
"PODCAST_STATS_HTML_EMAIL_BACKDROP_COLOR" \
"PODCAST_STATS_HTML_EMAIL_SECTION_HEADING_BACKDROP_COLOR" \
"PODCAST_STATS_HTML_EMAIL_SECTION_HEADING_FONT_NAME" \
"PODCAST_STATS_HTML_EMAIL_SECTION_HEADING_FONT_SIZE" \
"PODCAST_STATS_HTML_EMAIL_SECTION_HEADING_FONT_COLOR" \
"PODCAST_STATS_HTML_EMAIL_BODY_FONT_NAME" \
"PODCAST_STATS_HTML_EMAIL_BODY_FONT_SIZE" \
"PODCAST_STATS_HTML_EMAIL_BODY_FONT_COLOR" \
"NON_DOWNLOAD_ENTRY_PODCAST_LOG_AWS_S3_BUCKET_OBJECTS_DELETION" \
"IRRELEVANT_DOWNLOAD_ENTRY_PODCAST_LOG_AWS_S3_BUCKET_OBJECTS_DELETION" \
"RELEVANT_DOWNLOAD_ENTRY_PODCAST_LOG_AWS_S3_BUCKET_OBJECTS_DELETION" \
"PODCAST_STATS_REPORT_LANGUAGE"


Each environment variable value format must be used for each
command parameter.


Error recovery
==============
This software program handles podcast-stats emailing errors,
and podcast-stats AWS S3 objects saving errors.

If a podcast-stats email is not sent due to an AWS error, it will be sent
when this program is run again and there is no emailing error.

If a podcast-stats AWS S3 object is not saved due to an error, it will be saved
when this program is run again and there is no saving error.

If there's podcast-stats AWS S3 objects saving error, podcast-stats email(s)
were already sent, then the email(s) will be sent again (because
the podcast-stats AWS S3 objects are used as sent-email indicators).


What you should do as the user of this software program
=======================================================
Setting the auto-deletion on the podcast-stats AWS S3 buckets
with a storage period of longer than a month.


What you should NOT do as the user of this software program
===========================================================
Setting auto-deletion on the podcast-log AWS S3 buckets.

Manually deleting the podcast-log AWS S3 objects.

Manually deleting the podcast-stats AWS S3 objects.
"""


###############################################################################
#------------------------------------------------------------------------------
#Python Module Imports
#------------------------------------------------------------------------------
###############################################################################
import sys
import os
import re
import datetime
import calendar
import math

import boto3
import botocore.config
import botocore


class Aws_Podcast_Stats_Reporter(): #tag:  apsr
    def __init__(self):
        #######################################################################
        #----------------------------------------------------------------------
        #Class Data Variables
        #----------------------------------------------------------------------
        #######################################################################
        
        #################################
        #Program settings data variables
        #################################
        self.str_listPodcastNamesInStatsReports = []
        self.str_listPodcastEpisodeAwsS3BucketFolderPaths = []
        self.str_listPodcastLogAwsS3BucketFolderPaths = []
        self.str_listPodcastStatsAwsS3BucketFolderPaths = []
        
        self.strFirstColumnDataTypeInEmail = 'count' #'count' or 'name'
        
        self.strPodcastStatsSenderEmailAddress = ""
        self.strPodcastStatsSenderName = ""
        self.strPodcastStatsRecipientEmailAddress = ""
            
        self.bDailyPodcastStatsEmail = True
        self.bWeeklyPodcastStatsEmail = True
        self.bMonthlyPodcastStatsEmail = True
        
        self.bIncludeNumbersOfRetriesInPodcastStatsEmails = True
        
        self.bSeparatePodcastStatsEmails = False
        
        self.strPodcastStatsHtmlEmailBackdropColor = "_default_"
        self.strPodcastStatsHtmlEmailSectionHeadingBackdropColor = "_default_"
        self.strPodcastStatsHtmlEmailSectionHeadingFontName = "_default_"
        self.strPodcastStatsHtmlEmailSectionHeadingFontSize = "_default_"
        self.strPodcastStatsHtmlEmailSectionHeadingFontColor = "_default_"
        self.strPodcastStatsHtmlEmailBodyFontName = "_default_"
        self.strPodcastStatsHtmlEmailBodyFontSize = "_default_"
        self.strPodcastStatsHtmlEmailBodyFontColor = "_default_"
        
        self.bNonDownloadEntryPodcastLogAwsS3BucketObjectsDeletion = True
        self.bIrrelevantDownloadEntryPodcastLogAwsS3BucketObjectsDeletion = \
            True
        self.bRelevantDownloadEntryPodcastLogAwsS3BucketObjectsDeletion = True
        
        
        #######################
        #Parser data variables
        #######################
        self.regexp_objPodcastLogEntryParser = re.compile( \
            '([^ ]*) ([^ ]*) \\[(.*?)\\] ([^ ]*) ([^ ]*) ([^ ]*) ([^ ]*) \
([^ ]*) \\"([^ ]*) ([^ ]*) (- |[^ ]*)\\" (-|[0-9]*) ([^ ]*) ([^ ]*) ([^ ]*) \
([^ ]*) ([^ ]*) ([^ ]*) ("[^"]*") ([^ ]*)(?: ([^ ]*) ([^ ]*) ([^ ]*) ([^ ]*) \
([^ ]*) ([^ ]*))?.*$',
            re.IGNORECASE)
        
        self.regexp_objEmailAddressFormatValidator = re.compile( \
            r"[^@]+@[^@]+\.[^@]+", re.IGNORECASE)
        
        self.regexp_objRgbInputParameterParser = re.compile( \
            r"^rgb\((\d\d?\d?),(\d\d?\d?),(\d\d?\d?)\)$", re.IGNORECASE)
        
        self.regexp_objPodcastStatsAwsS3ObjectLineParser = re.compile( \
            r"^(.*?)\t(.*?)$", re.IGNORECASE)
        
        
        ############################
        #Podcast-log data variables
        ############################        
        self.dictDatesToPodcastNamesToDailyPodcastDownloadStatsDicts = {}
        #self.dictDatesToPodcastNamesToDailyPodcastDownloadStatsDicts =
            #{ date : dictPodcastNamesToPodcastDownloadStatsDicts, ... }
        #dictPodcastNamesToPodcastDownloadStatsDicts = 
            #{ strPodcastName : dictPodcastDownloadStats, ...}
            #dictPodcastDownloadStats = 
            #    {strPodcastEpisodeFileName : iDownloadCount, ...}
                #(dictPodcastEpisodeNamesToDownloadCounts)
        self.dictDatesToTotalNumbersOfPodcastLogAwsS3Objects = {}
        self.dictDatesToPodcastNamesToPodcastLogCounts = {}
            #self.dictDatesToPodcastNamesToPodcastLogCounts = 
            #{datePodcastDownload:dictPodcastNamesToPodcastLogCounts, ...}
            #dictPodcastNamesToPodcastLogCounts = 
            #    {strPodcastName:iPodcastLogCount, ...}
        self.dictDatesToPodcastNamesToPodcastLogAccessRetryCounts = {}
            #self.dictDatesToPodcastNamesToPodcastLogAccessRetryCounts = 
            #{datePodcastDownload:dictPodcastNamesToPodcastLogAccessRetryCounts
            #, ...}
            #dictPodcastNamesToPodcastLogAccessRetryCounts = 
            #{strPodcastName:iPodcastLogAccessRetryCount, ...}
            
        self.dictPodcastLogAwsS3BucketNamesToDeletionPodcastLogAwsS3ObjectKeyLists \
            = {}
        #str_listDeletionPodcastLogAwsS3ObjectKeys = 
        #    [strDeletionPodcastLogAwsS3ObjectKey, ...]
        #strDeletionPodcastLogAwsS3ObjectKey includes both AWS S3 object prefix 
        #and name.
        
        
        #######################################
        #Podcast-log processing data variables
        #######################################
        self.dateToday = None
        self.dateYesterday = None        
        
        aws_retry_config = botocore.config.Config( \
            connect_timeout=60, read_timeout=60,
            retries = {'max_attempts': 10, 'mode': 'standard'})        
        self.s3_resource = boto3.resource('s3', config=aws_retry_config)        

        self.bNonDownloadEntryPodcastLogAwsS3BucketObject = False
        self.bIrrelevantDownloadEntryPodcastLogAwsS3BucketObject = False
        self.bRelevantDownloadEntryPodcastLogAwsS3BucketObject = False
        
        self.bFutureEntryPodcastLogAwsS3BucketObject = False
        
        self.dictDatesToPodcastNameListsForCurrentPodcastLog = {}
        
        
        ########################################
        #Podcast-stats production data variables
        ########################################
        self.dictPodcastNamesToPodcastEpisodeAwsS3BucketFolderPaths = {}
        
        self.dictPodcastNamesToPodcastStatsAwsS3BucketFolderPaths = {}
        self.dictPodcastNamesToPodcastStatsAwsS3BucketNameAndObjectPrefixLists \
            = {}
            #str_listPodcastStatsAwsS3BucketNameAndObjectPrefix
            # = [strPodcastStatsAwsS3BucketName, 
            #    strPodcastStatsAwsS3ObjectPrefix]
            #strPodcastStatsAwsS3ObjectPrefix does not start with /,
            #and does not end with /.
        
        self.dictPodcastNamesToDailyPodcastDownloadStatsDicts = {}
        self.dictPodcastDownloadStats = {}
        
        self.dateCurrentPodcastDownload = None
        
        self.dateReportPeriodStart = None
        self.dateReportPeriodEnd = None
        
        self.strDateRange = ''
        self.strDateRangeType = '' #must be 'daily', 'weekly', or 'monthly'
        
        self.strCurrentPodcastName = ''
        
        self.strCurrentPodcastStatsAwsS3BucketName = ''
        self.strCurrentPodcastStatsAwsS3ObjectPrefix = '' #no / at the ends.
        
        self.strCurrentPodcastStatsAwsS3ObjectKey = '' #with starting /.
        
        self.str_listMissingPodcastStatsAwsS3ObjectPodcastNames = []
        self.str_list_listMissingPodcastStatsAwsS3ObjectBucketNameAndObjectKeyLists \
            = []
            #a list of missing daily podcast-log AWS S3 objects.
            #str_listPodcastStatsAwsS3BucketNameAndObjectKey
            # = [strPodcastStatsAwsS3BucketName, strPodcastStatsAwsS3ObjectKey]
        #The above two data variables are used for ... (elaborate)
        
        self.strEmailTitleHead = ''
        
        self.strEmailTitle = ''
        
        self.str_listHtmlEmailBody = []
        self.str_listPlainTextEmailBody = []
        
        self.strHtmlEmailBody = ''
        self.strPlainTextEmailBody = ''
        
        self.dictPodcastNamesToPodcastStatsEmailSendingRetryCounts = {}
        self.iPodcastStatsEmailSendingRetryCount = 0
        
        #total number of the missing daily podcast-stats AWS S3 objects 
        #containing one or more download stats for this weekly/monthly 
        #podcast-stats
        self.iNumberOfMissingDaysFromThisWeeklyOrMonthlyPodcastStatsReport = 0
        #total number of access retries on the daily podcast-stats AWS S3 
        #objects containing podcast-episode download stats for this 
        #weekly/monthly podcast-stats report
        self.iTotalNumberOfPodcastStatsAwsS3ObjectAccessRetriesInThisWeeklyOrMonthlyPodcastStatsReport \
            = 0
        #a comma-separated list of missing daily podcast-stats AWS S3 objects
        self.strCommaSeparatedListOfMissingDailyPodcastStatsAwsS3Objects = 0
        
        self.dictPodcastNamesToDateRangesToMissingDayCounts = {}
            #tupleDateRange = (dateStart, dateEnd)
            #(a global data variable for weekly/montly report)
            #"the total number of the missing daily podcast-stats AWS S3 
            #objects containing one or more download stats for this 
            #weekly/monthly podcast-stats"
        self.dictPodcastNamesToDateRangesToPodcastStatsAwsS3ObjectAccessRetryCounts \
            = {}
            #tupleDateRange = (dateStart, dateEnd)
            #(a global data variable for weekly/montly report)
            #"the total number of access retries on the daily podcast-stats 
            #AWS S3 objects containing one or more podcast-episode download 
            #stats for this weekly/monthly podcast-stats report"
        self.dictPodcastNamesToDateRangesToMissingDailyPodcastStatsAwsS3ObjectCommaSeparatedListStrings \
            = {}
            #tupleDateRange = (dateStart, dateEnd)
            #(a global data variable for weekly/montly report)
            #(a comma-separated list of missing daily podcast-stats AWS S3 
            #objects.)
        
        self.dictEndingDatesToPodcastNamesToWeeklyPodcastDownloadStatsDicts \
            = {}
        self.dictEndingDatesToPodcastNamesToMonthlyPodcastDownloadStatsDicts \
            = {}
        
        self.dictDateRangesToTotalDownloadCounts = {}
            #tupleDateRange = (dateStart, dateEnd)
        
        #self.dictPodcastNamesToPodcastDownloadStatsDicts = {}
        self.str_listPodcastStatsAwsS3ObjectContent = []
        self.strPodcastStatsAwsS3ObjectContent = ''

        
        self.strPodcastStatsReportLanguage = "English"
        self.str_tuplePodcastStatsReportSupportedLanguages = ("English",)
        self.dictLanguagesToAllPodcastsDailyDownloadCountDescriptors = { \
            "English": \
'str(iTotalNumberOfPodcastEpisodeDownloadsDuringThisPeriod) + " podcast \
episode(s) downloaded on " + self.strDateRange + ", in total."'}
        self.dictLanguagesToAllPodcastsNonDailyDownloadCountDescriptors = { \
            "English": \
'str(iTotalNumberOfPodcastEpisodeDownloadsDuringThisPeriod) + " podcast \
episode(s) downloaded between " + \
self.dateReportPeriodStart.strftime("%Y-%m-%d") + " and " + \
self.dateReportPeriodEnd.strftime("%Y-%m-%d") + ", in total."'}        
        self.dictLanguagesToTotalDailyPodcastLogCountDescriptors = { \
            "English": \
'"{" + str(self.dictDatesToTotalNumbersOfPodcastLogAwsS3Objects[\
self.dateCurrentPodcastDownload]) + " podcast-log AWS-S3 object(s) with one or\
 more of the podcast-episode download entries on " + self.strDateRange + ", in\
 total.}"'}
    
        self.dictLanguagesToPodcastDailyDownloadCountDescriptors = { \
            "English": \
'str(iTotalNumberOfPodcastEpisodeDownloadsDuringThisPeriod) + " " + \
strDoubleQuotedCurrentPodcastName +  " podcast episode(s) downloaded on " + \
self.strDateRange + ", in total."'}
        self.dictLanguagesToPodcastNonDailyDownloadCountDescriptors = { \
            "English": \
'str(iTotalNumberOfPodcastEpisodeDownloadsDuringThisPeriod) + " " + \
strDoubleQuotedCurrentPodcastName +  " podcast episode(s) downloaded between "\
 + self.dateReportPeriodStart.strftime("%Y-%m-%d") + " and " + \
self.dateReportPeriodEnd.strftime("%Y-%m-%d") + ", in total."'}       
        self.dictLanguagesToPodcastDailyAwsS3LogCountDescriptors = { \
            "English": \
'"{" + str(iPodcastLogCount) + " podcast-log AWS-S3 object(s) with one or more\
 of the " + strDoubleQuotedCurrentPodcastName + " podcast-episode download \
entries on " + self.strDateRange + ", in total.}"'}
        self.dictLanguagesToPodcastDailyAwsS3LogAccessRetryCountDescriptors = \
            {"English": \
'"{" + str(iPodcastLogAccessRetryCount) + " access retry(ies) on the \
podcast-log AWS-S3 object(s) with one or more of the " + \
strDoubleQuotedCurrentPodcastName + " podcast-episode download entries on " + \
self.strDateRange + ", in total.}"'}  


        self.dictLanguagesToTotalDailyPodcastLogCountDescriptors2 = { \
            "English":'"The total number of the podcast-log AWS S3 \
objects containing one or more of the podcast-episode download \
entries on this date:  " + \
str(self.dictDatesToTotalNumbersOfPodcastLogAwsS3Objects[\
self.dateCurrentPodcastDownload])'}
        self.dictLanguagesToPodcastDailyAwsS3LogCountDescriptors2 = { \
            "English": \
'"The total number of the podcast-log AWS S3 objects containing one or more \
download entries of this podcast\'s episodes on this date:  " + \
str(iPodcastLogCount)'}
        self.dictLanguagesToPodcastDailyAwsS3LogAccessRetryCountDescriptors2 \
            = {"English": \
'"The total number of access retries on the podcast-log AWS S3 objects \
containing one or more download entries of this podcast\'s episodes on this \
date:  " + str(iPodcastLogAccessRetryCount)'}
            
        self.dictLanguagesToEmailSendingRetriesDescriptors = \
            {"English": \
'"The total number of email-sending retries for this podcast for this reporting\
 period:  " + str(self.iPodcastStatsEmailSendingRetryCount)'}
            
        self.dictLanguagesToMissingDaysDescriptors = \
            {"English": \
'"The total number of missing days from this weekly or monthly podcast stats \
report for this podcast:  " + str( \
self.iNumberOfMissingDaysFromThisWeeklyOrMonthlyPodcastStatsReport)'}
        self.dictLanguagesToDailyPodcastStatsAwsS3ObjectAccessRetriesDescriptors \
            = {"English": \
'"The total number of daily podcast-stats AWS S3 object access retries for this\
 weekly or monthly podcast-stats report for this podcast:  " + str(\
self.iTotalNumberOfPodcastStatsAwsS3ObjectAccessRetriesInThisWeeklyOrMonthlyPodcastStatsReport\
)'} 
        self.dictLanguagesToMissingDailyPodcastStatsAwsS3ObjectsDescriptors = \
            {"English": \
'"The missing daily podcast-stats AWS S3 objects in this weekly or monthly \
podcast-stats report for this podcast:  " + str(\
self.strCommaSeparatedListOfMissingDailyPodcastStatsAwsS3Objects)'}
        

        #####################################
        #Podcast-stats sending data variables
        #####################################
        self.ses_client = boto3.client('ses')


    ###########################################################################
    #--------------------------------------------------------------------------
    #Functions
    #--------------------------------------------------------------------------
    ###########################################################################
    
    def _ValidateAwsS3BucketExistence(self, strBucketName):
        #returns True if the bucket exists; returns False if the bucket doesn't
        #exist.
        
        bucket = self.s3_resource.Bucket(strBucketName)
        bBucketExists = True
        try:
            self.s3_resource.meta.client.head_bucket(Bucket=strBucketName)
        except botocore.exceptions.ClientError as e:
            # If a client error is thrown, then check that it was a 404 error.
            # If it was a 404 error, then the bucket does not exist.
            strErrorCode = e.response['Error']['Code']
            if strErrorCode == '404':
                bBucketExists = False
            else:
                #Something else has gone wrong.
                raise Exception( \
                    'Error while querying an AWS S3 bucket existence.  ' + \
                    strBucketName + '\n' + str(e))            
                
        return bBucketExists
    
    def _ValidateRgbInputParameter(self, strRgbInputParameter):
        #returns True if the input is valid; returns false if the input is 
        #invalid.
        regexp_match_objRgbInputParameter = \
            self.regexp_objRgbInputParameterParser.search(strRgbInputParameter)
            
        if regexp_match_objRgbInputParameter == None:
            return False
        
        try:
            iRed = int(regexp_match_objRgbInputParameter.group(1))
            if iRed < 0 or iRed > 255:
                return False
        except:
            return False
        
        try:
            iGreen = int(regexp_match_objRgbInputParameter.group(2))
            if iGreen < 0 or iGreen > 255:
                return False
        except:
            return False
    
        try:
            iBlue = int(regexp_match_objRgbInputParameter.group(3))
            if iBlue < 0 or iBlue > 255:
                return False
        except:
            return False   
        
        return True
    
    def _ConvertAllAwsS3BucketNamesToLowercase(self,
        str_listAwsS3BucketFolderPaths):
        
        if len(str_listAwsS3BucketFolderPaths) == 0:
            raise Exception("An invalid input setting.  An AWS S3 bucket \
folder path list must not be empty.")
        
        for iZeroBasedIndex in range(0, len(str_listAwsS3BucketFolderPaths)):
            strAwsS3BucketFolderPath = \
                str_listAwsS3BucketFolderPaths[iZeroBasedIndex]
            str_listAwsS3BucketFolderPath = \
                strAwsS3BucketFolderPath.split('/', 1)
                
            if len(str_listAwsS3BucketFolderPath) == 1:
                strAwsS3BucketFolderPath = \
                    strAwsS3BucketFolderPath.lower()
            else:
                strAwsS3BucketFolderPath = \
                    str_listAwsS3BucketFolderPath[0].lower() + '/' + \
                    str_listAwsS3BucketFolderPath[1]
                    
            str_listAwsS3BucketFolderPaths[iZeroBasedIndex] = \
                strAwsS3BucketFolderPath    
        
    
    def LoadSettings(self):
        #If run in a terminal (CLI) with command parameters,
        #get the settings from the command parameters.
        #
        #If run as an AWS Lambda function, or in a terminal without parameters,
        #get the settings from the environment variables.
        #
        #Use the environment variables when len(sys.argv) is smaller than 2.
        
        
        if len(sys.argv) > 1 and len(sys.argv) != 26:
            raise Exception("Incorrect number of command parameters.")
            
            
        #####################################
        #Get PODCAST_NAMES_IN_STATS_REPORTS.
        #####################################
        if len(sys.argv) > 1:
            #Get the setting from the command parameter.
            self.str_listPodcastNamesInStatsReports = sys.argv[1]
        else:
            #Get the setting from the environment variable.
            if "PODCAST_NAMES_IN_STATS_REPORTS" in os.environ:
                self.str_listPodcastNamesInStatsReports = \
                    os.environ['PODCAST_NAMES_IN_STATS_REPORTS']
            else:
                raise Exception("PODCAST_NAMES_IN_STATS_REPORTS " + \
                                "environment variable is not defined.")
                
        try:
            self.str_listPodcastNamesInStatsReports = eval("[" + \
                self.str_listPodcastNamesInStatsReports + "]")
        except:
            raise Exception("PODCAST_NAMES_IN_STATS_REPORTS value is invalid.")        
    
        #Check that each item of self.str_listPodcastNamesInStatsReports
        #is a string.
        for strPodcastNameInStatsReport in \
            self.str_listPodcastNamesInStatsReports:
            if not isinstance(strPodcastNameInStatsReport, str):
                raise Exception("PODCAST_NAMES_IN_STATS_REPORTS setting \
contains a non-string item.")
                
        #Enforce the uniqueness of the podcast names.
        if len(self.str_listPodcastNamesInStatsReports) > \
            len(set(self.str_listPodcastNamesInStatsReports)):
            raise Exception('Invalid input.  Redundant podcast names.  Every \
podcast name must be unique.')
                
        
        ################################################
        #Get PODCAST_EPISODE_AWS_S3_BUCKET_FOLDER_PATHS.
        ################################################
        if len(sys.argv) > 1:
            #Get the setting from the command parameter.
            self.str_listPodcastEpisodeAwsS3BucketFolderPaths = sys.argv[2]
        else:
            #Get the setting from the environment variable.
            if "PODCAST_EPISODE_AWS_S3_BUCKET_FOLDER_PATHS" in os.environ:
                self.str_listPodcastEpisodeAwsS3BucketFolderPaths = \
                    os.environ['PODCAST_EPISODE_AWS_S3_BUCKET_FOLDER_PATHS']
            else:
                raise Exception("PODCAST_EPISODE_AWS_S3_BUCKET_FOLDER_PATHS \
environment variable is not defined.")
                
        try:
            self.str_listPodcastEpisodeAwsS3BucketFolderPaths = eval("[" + \
                self.str_listPodcastEpisodeAwsS3BucketFolderPaths + "]")
        except:
            raise Exception("PODCAST_EPISODE_AWS_S3_BUCKET_FOLDER_PATHS value \
is invalid.")        
    
        #Check that each item of self.str_listPodcastEpisodeAwsS3BucketFolderPaths
        #is a string.
        for strPodcastEpisodeAwsS3BucketFolderPath in \
            self.str_listPodcastEpisodeAwsS3BucketFolderPaths:
            if not isinstance(strPodcastEpisodeAwsS3BucketFolderPath, str):
                raise Exception("PODCAST_EPISODE_AWS_S3_BUCKET_FOLDER_PATHS \
setting contains a non-string item.")
                
        #Ensure that each in-memory AWS S3 bucket folder path does not end 
        #with /.
        self.str_listPodcastEpisodeAwsS3BucketFolderPaths = [ \
            strPodcastEpisodeAwsS3BucketFolderPath[:-1] \
            if strPodcastEpisodeAwsS3BucketFolderPath[-1] == '/' \
            else strPodcastEpisodeAwsS3BucketFolderPath \
            for strPodcastEpisodeAwsS3BucketFolderPath in \
            self.str_listPodcastEpisodeAwsS3BucketFolderPaths]
    
        #Convert all the AWS S3 bucket names to lowercase.
        self._ConvertAllAwsS3BucketNamesToLowercase( \
            self.str_listPodcastEpisodeAwsS3BucketFolderPaths)
    
        #Enforce the uniqueness of the podcast-episode AWS S3 bucket folder 
        #paths.
        if len(self.str_listPodcastEpisodeAwsS3BucketFolderPaths) > \
            len(set(self.str_listPodcastEpisodeAwsS3BucketFolderPaths)):
            raise Exception('Invalid input.  Redundant podcast-episode AWS S3 \
bucket folder paths.  Every podcast-episode AWS S3 bucket folder path must be \
unique.')
           
        
        ############################################
        #Get PODCAST_LOG_AWS_S3_BUCKET_FOLDER_PATHS.
        ############################################
        if len(sys.argv) > 1:
            #Get the setting from the command parameter.
            self.str_listPodcastLogAwsS3BucketFolderPaths = sys.argv[3]
        else:
            #Get the setting from the environment variable.
            if "PODCAST_LOG_AWS_S3_BUCKET_FOLDER_PATHS" in os.environ:
                self.str_listPodcastLogAwsS3BucketFolderPaths = \
                    os.environ['PODCAST_LOG_AWS_S3_BUCKET_FOLDER_PATHS']
            else:
                raise Exception("PODCAST_LOG_AWS_S3_BUCKET_FOLDER_PATHS \
environment variable is not defined.")
                
        try:
            self.str_listPodcastLogAwsS3BucketFolderPaths = eval("[" + \
                self.str_listPodcastLogAwsS3BucketFolderPaths + "]")
        except:
            raise Exception("PODCAST_LOG_AWS_S3_BUCKET_FOLDER_PATHS value is \
invalid.")        
    
        #Check that each item of self.str_listPodcastLogAwsS3BucketFolderPaths
        #is a string.
        for strPodcastLogAwsS3BucketFolderPath in \
            self.str_listPodcastLogAwsS3BucketFolderPaths:
            if not isinstance(strPodcastLogAwsS3BucketFolderPath, str):
                raise Exception("PODCAST_LOG_AWS_S3_BUCKET_FOLDER_PATHS \
setting contains a non-string item.")
                
        #Ensure that each in-memory AWS S3 bucket folder path does not end 
        #with /.
        self.str_listPodcastLogAwsS3BucketFolderPaths = [ \
            strPodcastLogAwsS3BucketFolderPath[:-1] \
            if strPodcastLogAwsS3BucketFolderPath[-1] == '/' \
            else strPodcastLogAwsS3BucketFolderPath \
            for strPodcastLogAwsS3BucketFolderPath in \
            self.str_listPodcastLogAwsS3BucketFolderPaths]
        
        #Convert all the AWS S3 bucket names to lowercase.
        self._ConvertAllAwsS3BucketNamesToLowercase( \
            self.str_listPodcastLogAwsS3BucketFolderPaths)    
        
        #Enforce the uniqueness of the podcast-log AWS S3 bucket folder paths.
        if len(self.str_listPodcastLogAwsS3BucketFolderPaths) > \
            len(set(self.str_listPodcastLogAwsS3BucketFolderPaths)):
            raise Exception('Invalid input.  Redundant podcast-log AWS S3 \
bucket folder paths.  Every podcast-log AWS S3 bucket folder path must be \
unique.')
               
        #Enforce the non-redundant podcast logs processing.
        for strPodcastLogAwsS3BucketFolderPath1 in \
            self.str_listPodcastLogAwsS3BucketFolderPaths:    
        
            if '/' in strPodcastLogAwsS3BucketFolderPath1: continue
        
            for strPodcastLogAwsS3BucketFolderPath2 in \
                self.str_listPodcastLogAwsS3BucketFolderPaths:
                    
                if strPodcastLogAwsS3BucketFolderPath1 == \
                    strPodcastLogAwsS3BucketFolderPath2: continue
                
                if strPodcastLogAwsS3BucketFolderPath2.split('/', 1)[0] == \
                    strPodcastLogAwsS3BucketFolderPath1:
                    raise Exception('Invalid input in \
PODCAST_LOG_AWS_S3_BUCKET_FOLDER_PATHS.  The following podcast-log AWS S3 \
bucket folder paths would result in redundant podcast-logs processing.  ' + \
                        strPodcastLogAwsS3BucketFolderPath1 + ', ' + \
                        strPodcastLogAwsS3BucketFolderPath2 + '.')
            
        
        ##############################################
        #Get PODCAST_STATS_AWS_S3_BUCKET_FOLDER_PATHS.
        ##############################################
        if len(sys.argv) > 1:
            #Get the setting from the command parameter.
            self.str_listPodcastStatsAwsS3BucketFolderPaths = sys.argv[4]
        else:
            #Get the setting from the environment variable.
            if "PODCAST_STATS_AWS_S3_BUCKET_FOLDER_PATHS" in os.environ:
                self.str_listPodcastStatsAwsS3BucketFolderPaths = \
                    os.environ['PODCAST_STATS_AWS_S3_BUCKET_FOLDER_PATHS']
            else:
                raise Exception("PODCAST_STATS_AWS_S3_BUCKET_FOLDER_PATHS \
environment variable is not defined.")
                
        try:
            self.str_listPodcastStatsAwsS3BucketFolderPaths = eval("[" + \
                self.str_listPodcastStatsAwsS3BucketFolderPaths + "]")
        except:
            raise Exception("PODCAST_STATS_AWS_S3_BUCKET_FOLDER_PATHS value is \
invalid.")        
    
        #Check that each item of self.str_listPodcastStatsAwsS3BucketFolderPaths
        #is a string.
        for strPodcastStatsAwsS3BucketFolderPath in \
            self.str_listPodcastStatsAwsS3BucketFolderPaths:
            if not isinstance(strPodcastStatsAwsS3BucketFolderPath, str):
                raise Exception("PODCAST_STATS_AWS_S3_BUCKET_FOLDER_PATHS \
setting contains a non-string item.")
                
        #Ensure that each in-memory AWS S3 bucket folder path does not end 
        #with /.
        self.str_listPodcastStatsAwsS3BucketFolderPaths = [ \
            strPodcastStatsAwsS3BucketFolderPath[:-1] \
            if strPodcastStatsAwsS3BucketFolderPath[-1] == '/' \
            else strPodcastStatsAwsS3BucketFolderPath \
            for strPodcastStatsAwsS3BucketFolderPath in \
            self.str_listPodcastStatsAwsS3BucketFolderPaths]            
    
        #Convert all the AWS S3 bucket names to lowercase.
        self._ConvertAllAwsS3BucketNamesToLowercase( \
            self.str_listPodcastStatsAwsS3BucketFolderPaths)  
    
                
        #########################################################
        #Validate the podcast input parameters (name and AWS S3).
        ######################################################### 
    
        #Check that all the applicable input lists have the same length.
        if len(self.str_listPodcastNamesInStatsReports) != \
            len(self.str_listPodcastEpisodeAwsS3BucketFolderPaths) or \
            len(self.str_listPodcastNamesInStatsReports) != \
            len(self.str_listPodcastStatsAwsS3BucketFolderPaths):
            raise Exception( \
                "The numbers of podcast names, podcast-episode AWS S3 bucket \
folder paths, and podcast-stats AWS S3 bucket folder paths must be the same.")
            
        #Validate the number of podcast-log AWS S3 bucket folder paths.
        if len(self.str_listPodcastLogAwsS3BucketFolderPaths) == 0 or \
            len(self.str_listPodcastLogAwsS3BucketFolderPaths) > \
            len(self.str_listPodcastEpisodeAwsS3BucketFolderPaths):
            raise Exception( \
                "The number of podcast-log AWS S3 bucket folder paths, must \
be least one, and smaller than or equal to the number of podcast-episode AWS \
S3 bucket folder paths.")
            
            
        #Make sure that each specified AWS S3 bucket contains only one type of 
        #data (podcast episode, podcast logs, or podcast stats).
        #That is, make sure that each AWS S3 bucket specified in each path list
        #is absent from the other two path lists.
        #(UPDATE [9/7/2020 8:56 AM CST] Using the same AWS S3 bucket for both
        #the log and stat folders is now allowed.  They just need to be
        #not the same folder.) 
            
        #Build the lists of AWS S3 bucket names to use in validating 
        #bucket-usage type uniqueness.
        str_listPodcastEpisodeAwsS3BucketNames = []
        str_listPodcastLogAwsS3BucketNames = []
        str_listPodcastStatsAwsS3BucketNames = []
        
        for strPodcastEpisodeAwsS3BucketFolderPath in \
            self.str_listPodcastEpisodeAwsS3BucketFolderPaths:
            strPodcastEpisodeAwsS3BucketName = \
                strPodcastEpisodeAwsS3BucketFolderPath.split('/', 1)[0]
            if strPodcastEpisodeAwsS3BucketName not in \
                str_listPodcastEpisodeAwsS3BucketNames:
                str_listPodcastEpisodeAwsS3BucketNames.append( \
                    strPodcastEpisodeAwsS3BucketName)
                
        for strPodcastLogAwsS3BucketFolderPath in \
            self.str_listPodcastLogAwsS3BucketFolderPaths:
            strPodcastLogAwsS3BucketName = \
                strPodcastLogAwsS3BucketFolderPath.split('/', 1)[0]
            if strPodcastLogAwsS3BucketName not in \
                str_listPodcastLogAwsS3BucketNames:
                str_listPodcastLogAwsS3BucketNames.append( \
                    strPodcastLogAwsS3BucketName)
    
        for strPodcastStatsAwsS3BucketFolderPath in \
            self.str_listPodcastStatsAwsS3BucketFolderPaths:
            strPodcastStatsAwsS3BucketName = \
                strPodcastStatsAwsS3BucketFolderPath.split('/', 1)[0]
            if strPodcastStatsAwsS3BucketName not in \
                str_listPodcastStatsAwsS3BucketNames:
                str_listPodcastStatsAwsS3BucketNames.append( \
                    strPodcastStatsAwsS3BucketName)    
                
        #Check that the AWS S3 bucket names in 
        #str_listPodcastEpisodeAwsS3BucketNames are not present in 
        #str_listPodcastLogAwsS3BucketNames and 
        #str_listPodcastStatsAwsS3BucketNames.
        for strPodcastEpisodeAwsS3BucketName in \
            str_listPodcastEpisodeAwsS3BucketNames:
            
            if strPodcastEpisodeAwsS3BucketName in str_listPodcastLogAwsS3BucketNames:
                raise Exception("Wrong input.  A podcast-episode AWS S3 \
bucket is also a podcast-log AWS S3 bucket.")
            
            if strPodcastEpisodeAwsS3BucketName in str_listPodcastStatsAwsS3BucketNames:
                raise Exception("Wrong input.  A podcast-episode AWS S3 \
bucket is also a podcast-stats AWS S3 bucket.")
                    
        #Check that the AWS S3 bucket names in 
        #str_listPodcastLogAwsS3BucketNames are not present in 
        #str_listPodcastStatsAwsS3BucketNames.
        #for strPodcastLogAwsS3BucketName in str_listPodcastLogAwsS3BucketNames:
            #if strPodcastLogAwsS3BucketName in str_listPodcastStatsAwsS3BucketNames:
                #raise Exception("Wrong input.  A podcast-log AWS S3 bucket is \
#also a podcast-stats AWS S3 bucket.")    
 
        #Check that the AWS S3 bucket folder names in 
        #str_listPodcastLogAwsS3BucketNames are not present in 
        #str_listPodcastStatsAwsS3BucketNames.
        for strPodcastLogAwsS3BucketFolderPath in \
            self.str_listPodcastLogAwsS3BucketFolderPaths:
            for strPodcastStatsAwsS3BucketFolderPath in \
                self.str_listPodcastStatsAwsS3BucketFolderPaths:
                if strPodcastLogAwsS3BucketFolderPath == \
                    strPodcastStatsAwsS3BucketFolderPath:
                    raise Exception("Wrong input.  A podcast-log AWS S3 bucket \
folder is also a podcast-stats AWS S3 bucket folder.")     
            
            
        #Validate the AWS S3 bucket existences, for every AWS S3 bucket 
        #specified.
        str_listUniqueAwsS3BucketNames = \
            str_listPodcastEpisodeAwsS3BucketNames + \
            str_listPodcastLogAwsS3BucketNames + \
            str_listPodcastStatsAwsS3BucketNames
    
        for strBucketName in str_listUniqueAwsS3BucketNames:
            if not self._ValidateAwsS3BucketExistence(strBucketName):
                raise Exception(strBucketName + \
                    " AWS S3 bucket does not exist.")
       
    
        ######################################
        #Get FIRST_COLUMN_DATA_TYPE_IN_EMAIL.
        ######################################
        if len(sys.argv) > 1:
            #Get the setting from the command parameter.
            self.strFirstColumnDataTypeInEmail = sys.argv[5]
        else:
            #Get the setting from the environment variable.
            if "FIRST_COLUMN_DATA_TYPE_IN_EMAIL" in os.environ:
                self.strFirstColumnDataTypeInEmail = \
                    os.environ['FIRST_COLUMN_DATA_TYPE_IN_EMAIL']
            else:
                self.strFirstColumnDataTypeInEmail = 'count'
                
        if self.strFirstColumnDataTypeInEmail != 'count' and \
            self.strFirstColumnDataTypeInEmail != 'name':
            raise Exception("FIRST_COLUMN_DATA_TYPE_IN_EMAIL value is invalid.") 
            
            
        ########################################
        #Get PODCAST_STATS_SENDER_EMAIL_ADDRESS.
        ########################################
        if len(sys.argv) > 1:
            #Get the setting from the command parameter.
            self.strPodcastStatsSenderEmailAddress = sys.argv[6]
        else:
            #Get the setting from the environment variable.
            if "PODCAST_STATS_SENDER_EMAIL_ADDRESS" in os.environ:
                self.strPodcastStatsSenderEmailAddress = \
                    os.environ['PODCAST_STATS_SENDER_EMAIL_ADDRESS']
            else:
                raise Exception("PODCAST_STATS_SENDER_EMAIL_ADDRESS \
environment variable is not defined.")
                
        regexp_match_objEmailAddress = \
            self.regexp_objEmailAddressFormatValidator.fullmatch( \
                self.strPodcastStatsSenderEmailAddress)
        if regexp_match_objEmailAddress == None:
            raise Exception("PODCAST_STATS_SENDER_EMAIL_ADDRESS value is \
invalid.")
            
    
        ###############################
        #Get PODCAST_STATS_SENDER_NAME.
        ###############################
        if len(sys.argv) > 1:
            #Get the setting from the command parameter.
            self.strPodcastStatsSenderName = sys.argv[7]
        else:
            #Get the setting from the environment variable.
            if "PODCAST_STATS_SENDER_NAME" in os.environ:
                self.strPodcastStatsSenderName = \
                    os.environ['PODCAST_STATS_SENDER_NAME']
            else:
                self.strPodcastStatsSenderName = "Podcast Reports"
                
    
        ###########################################
        #Get PODCAST_STATS_RECIPIENT_EMAIL_ADDRESS.
        ###########################################
        if len(sys.argv) > 1:
            #Get the setting from the command parameter.
            self.strPodcastStatsRecipientEmailAddress = sys.argv[8]
        else:
            #Get the setting from the environment variable.
            if "PODCAST_STATS_RECIPIENT_EMAIL_ADDRESS" in os.environ:
                self.strPodcastStatsRecipientEmailAddress = \
                    os.environ['PODCAST_STATS_RECIPIENT_EMAIL_ADDRESS']
            else:
                raise Exception("PODCAST_STATS_RECIPIENT_EMAIL_ADDRESS \
environment variable is not defined.")
            
        regexp_match_objEmailAddress = \
            self.regexp_objEmailAddressFormatValidator.fullmatch( \
                self.strPodcastStatsRecipientEmailAddress)
        if regexp_match_objEmailAddress == None:
            raise Exception("PODCAST_STATS_RECIPIENT_EMAIL_ADDRESS value is \
invalid.")        
    
    
        ###############################
        #Get DAILY_PODCAST_STATS_EMAIL.
        ###############################
        if len(sys.argv) > 1:
            #Get the setting from the command parameter.
            self.bDailyPodcastStatsEmail = sys.argv[9]
        else:
            #Get the setting from the environment variable.
            if "DAILY_PODCAST_STATS_EMAIL" in os.environ:
                self.bDailyPodcastStatsEmail = \
                    os.environ['DAILY_PODCAST_STATS_EMAIL']
            else:
                self.bDailyPodcastStatsEmail = "True"
                
        if self.bDailyPodcastStatsEmail == "True":
            self.bDailyPodcastStatsEmail = True
        elif self.bDailyPodcastStatsEmail == "False":
            self.bDailyPodcastStatsEmail = False
        else:
            raise Exception("DAILY_PODCAST_STATS_EMAIL value is invalid.")
    
    
        ################################
        #Get WEEKLY_PODCAST_STATS_EMAIL.
        ################################
        if len(sys.argv) > 1:
            #Get the setting from the command parameter.
            self.bWeeklyPodcastStatsEmail = sys.argv[10]
        else:
            #Get the setting from the environment variable.
            if "WEEKLY_PODCAST_STATS_EMAIL" in os.environ:
                self.bWeeklyPodcastStatsEmail = \
                    os.environ['WEEKLY_PODCAST_STATS_EMAIL']
            else:
                self.bWeeklyPodcastStatsEmail = "True"
                
        if self.bWeeklyPodcastStatsEmail == "True":
            self.bWeeklyPodcastStatsEmail = True
        elif self.bWeeklyPodcastStatsEmail == "False":
            self.bWeeklyPodcastStatsEmail = False
        else:
            raise Exception("WEEKLY_PODCAST_STATS_EMAIL value is invalid.")
            
            
        #################################
        #Get MONTHLY_PODCAST_STATS_EMAIL.
        #################################
        if len(sys.argv) > 1:
            #Get the setting from the command parameter.
            self.bMonthlyPodcastStatsEmail = sys.argv[11]
        else:
            #Get the setting from the environment variable.
            if "MONTHLY_PODCAST_STATS_EMAIL" in os.environ:
                self.bMonthlyPodcastStatsEmail = \
                    os.environ['MONTHLY_PODCAST_STATS_EMAIL']
            else:
                self.bMonthlyPodcastStatsEmail = "True"
                
        if self.bMonthlyPodcastStatsEmail == "True":
            self.bMonthlyPodcastStatsEmail = True
        elif self.bMonthlyPodcastStatsEmail == "False":
            self.bMonthlyPodcastStatsEmail = False
        else:
            raise Exception("MONTHLY_PODCAST_STATS_EMAIL value is invalid.")
            
            
        ########################################################
        #Get INCLUDE_NUMBERS_OF_RETRIES_IN_PODCAST_STATS_EMAILS.
        ########################################################
        if len(sys.argv) > 1:
            #Get the setting from the command parameter.
            self.bIncludeNumbersOfRetriesInPodcastStatsEmails = sys.argv[12]
        else:
            #Get the setting from the environment variable.
            if "INCLUDE_NUMBERS_OF_RETRIES_IN_PODCAST_STATS_EMAILS" in os.environ:
                self.bIncludeNumbersOfRetriesInPodcastStatsEmails = \
                    os.environ[ \
                    'INCLUDE_NUMBERS_OF_RETRIES_IN_PODCAST_STATS_EMAILS']
            else:
                self.bIncludeNumbersOfRetriesInPodcastStatsEmails = "False"
                
        if self.bIncludeNumbersOfRetriesInPodcastStatsEmails == "True":
            self.bIncludeNumbersOfRetriesInPodcastStatsEmails = True
        elif self.bIncludeNumbersOfRetriesInPodcastStatsEmails == "False":
            self.bIncludeNumbersOfRetriesInPodcastStatsEmails = False
        else:
            raise Exception("INCLUDE_NUMBERS_OF_RETRIES_IN_PODCAST_STATS_EMAILS\
 value is invalid.")
            
            
        ###################################
        #Get SEPARATE_PODCAST_STATS_EMAILS.
        ###################################
        if len(sys.argv) > 1:
            #Get the setting from the command parameter.
            self.bSeparatePodcastStatsEmails = sys.argv[13]
        else:
            #Get the setting from the environment variable.
            if "SEPARATE_PODCAST_STATS_EMAILS" in os.environ:
                self.bSeparatePodcastStatsEmails = \
                    os.environ['SEPARATE_PODCAST_STATS_EMAILS']
            else:
                self.bSeparatePodcastStatsEmails = "False"
                
        if self.bSeparatePodcastStatsEmails == "True":
            self.bSeparatePodcastStatsEmails = True
        elif self.bSeparatePodcastStatsEmails == "False":
            self.bSeparatePodcastStatsEmails = False
        else:
            raise Exception("SEPARATE_PODCAST_STATS_EMAILS value is invalid.")
                    
    
        #############################################
        #Get PODCAST_STATS_HTML_EMAIL_BACKDROP_COLOR.
        #############################################
        if len(sys.argv) > 1:
            #Get the setting from the command parameter.
            self.strPodcastStatsHtmlEmailBackdropColor = sys.argv[14]
        else:
            #Get the setting from the environment variable.
            if "PODCAST_STATS_HTML_EMAIL_BACKDROP_COLOR" in os.environ:
                self.strPodcastStatsHtmlEmailBackdropColor = \
                    os.environ['PODCAST_STATS_HTML_EMAIL_BACKDROP_COLOR']
            else:
                self.strPodcastStatsHtmlEmailBackdropColor = "_default_"
                
        self.strPodcastStatsHtmlEmailBackdropColor = \
            self.strPodcastStatsHtmlEmailBackdropColor.lower()
                
        if self.strPodcastStatsHtmlEmailBackdropColor != '_default_':
            if not self._ValidateRgbInputParameter( \
                self.strPodcastStatsHtmlEmailBackdropColor):
                raise Exception("PODCAST_STATS_HTML_EMAIL_BACKDROP_COLOR \
value is invalid.")
            
    
        #############################################################
        #Get PODCAST_STATS_HTML_EMAIL_SECTION_HEADING_BACKDROP_COLOR.
        #############################################################
        if len(sys.argv) > 1:
            #Get the setting from the command parameter.
            self.strPodcastStatsHtmlEmailSectionHeadingBackdropColor = \
                sys.argv[15]
        else:
            #Get the setting from the environment variable.
            if "PODCAST_STATS_HTML_EMAIL_SECTION_HEADING_BACKDROP_COLOR" in \
                os.environ:
                self.strPodcastStatsHtmlEmailSectionHeadingBackdropColor = \
                    os.environ[ \
                    'PODCAST_STATS_HTML_EMAIL_SECTION_HEADING_BACKDROP_COLOR']
            else:
                self.strPodcastStatsHtmlEmailSectionHeadingBackdropColor = \
                    "rgb(0,0,100)"
             
        self.strPodcastStatsHtmlEmailSectionHeadingBackdropColor = \
            self.strPodcastStatsHtmlEmailSectionHeadingBackdropColor.lower()
                   
        if self.strPodcastStatsHtmlEmailSectionHeadingBackdropColor != \
            '_default_':
            if not self._ValidateRgbInputParameter( \
                self.strPodcastStatsHtmlEmailSectionHeadingBackdropColor):
                raise Exception( \
                    "PODCAST_STATS_HTML_EMAIL_SECTION_HEADING_BACKDROP_COLOR \
value is invalid.")        
            
    
        ########################################################
        #Get PODCAST_STATS_HTML_EMAIL_SECTION_HEADING_FONT_NAME.
        ########################################################
        if len(sys.argv) > 1:
            #Get the setting from the command parameter.
            self.strPodcastStatsHtmlEmailSectionHeadingFontName = sys.argv[16]
        else:
            #Get the setting from the environment variable.
            if "PODCAST_STATS_HTML_EMAIL_SECTION_HEADING_FONT_NAME" in \
                os.environ:
                self.strPodcastStatsHtmlEmailSectionHeadingFontName = \
                    os.environ[ \
                        'PODCAST_STATS_HTML_EMAIL_SECTION_HEADING_FONT_NAME']
            else:
                self.strPodcastStatsHtmlEmailSectionHeadingFontName = \
                    "_default_"
                
    
        ########################################################
        #Get PODCAST_STATS_HTML_EMAIL_SECTION_HEADING_FONT_SIZE.
        ########################################################
        if len(sys.argv) > 1:
            #Get the setting from the command parameter.
            self.strPodcastStatsHtmlEmailSectionHeadingFontSize = sys.argv[17]
        else:
            #Get the setting from the environment variable.
            if "PODCAST_STATS_HTML_EMAIL_SECTION_HEADING_FONT_SIZE" in \
                os.environ:
                self.strPodcastStatsHtmlEmailSectionHeadingFontSize = \
                    os.environ[ \
                        'PODCAST_STATS_HTML_EMAIL_SECTION_HEADING_FONT_SIZE']
            else:
                self.strPodcastStatsHtmlEmailSectionHeadingFontSize = \
                    "_default_"
    
    
        #########################################################
        #Get PODCAST_STATS_HTML_EMAIL_SECTION_HEADING_FONT_COLOR.
        #########################################################
        if len(sys.argv) > 1:
            #Get the setting from the command parameter.
            self.strPodcastStatsHtmlEmailSectionHeadingFontColor = sys.argv[18]
        else:
            #Get the setting from the environment variable.
            if "PODCAST_STATS_HTML_EMAIL_SECTION_HEADING_FONT_COLOR" in \
                os.environ:
                self.strPodcastStatsHtmlEmailSectionHeadingFontColor = \
                    os.environ[ \
                        'PODCAST_STATS_HTML_EMAIL_SECTION_HEADING_FONT_COLOR']
            else:
                self.strPodcastStatsHtmlEmailSectionHeadingFontColor = \
                    "rgb(255,255,255)"
             
        self.strPodcastStatsHtmlEmailSectionHeadingFontColor = \
            self.strPodcastStatsHtmlEmailSectionHeadingFontColor.lower()
                
        if self.strPodcastStatsHtmlEmailSectionHeadingFontColor != "_default_":
            if not self._ValidateRgbInputParameter( \
                self.strPodcastStatsHtmlEmailSectionHeadingFontColor):
                raise Exception( \
                    "PODCAST_STATS_HTML_EMAIL_SECTION_HEADING_FONT_COLOR \
value is invalid.")        
            
    
        #############################################
        #Get PODCAST_STATS_HTML_EMAIL_BODY_FONT_NAME.
        #############################################
        if len(sys.argv) > 1:
            #Get the setting from the command parameter.
            self.strPodcastStatsHtmlEmailBodyFontName = sys.argv[19]
        else:
            #Get the setting from the environment variable.
            if "PODCAST_STATS_HTML_EMAIL_BODY_FONT_NAME" in os.environ:
                self.strPodcastStatsHtmlEmailBodyFontName = \
                    os.environ['PODCAST_STATS_HTML_EMAIL_BODY_FONT_NAME']
            else:
                self.strPodcastStatsHtmlEmailBodyFontName = "_default_"
                
         
        #############################################
        #Get PODCAST_STATS_HTML_EMAIL_BODY_FONT_SIZE.
        #############################################
        if len(sys.argv) > 1:
            #Get the setting from the command parameter.
            self.strPodcastStatsHtmlEmailBodyFontSize = sys.argv[20]
        else:
            #Get the setting from the environment variable.
            if "PODCAST_STATS_HTML_EMAIL_BODY_FONT_SIZE" in os.environ:
                self.strPodcastStatsHtmlEmailBodyFontSize = \
                    os.environ['PODCAST_STATS_HTML_EMAIL_BODY_FONT_SIZE']
            else:
                self.strPodcastStatsHtmlEmailBodyFontSize = "_default_"
     
       
        ##############################################
        #Get PODCAST_STATS_HTML_EMAIL_BODY_FONT_COLOR.
        ##############################################
        if len(sys.argv) > 1:
            #Get the setting from the command parameter.
            self.strPodcastStatsHtmlEmailBodyFontColor = sys.argv[21]
        else:
            #Get the setting from the environment variable.
            if "PODCAST_STATS_HTML_EMAIL_BODY_FONT_COLOR" in os.environ:
                self.strPodcastStatsHtmlEmailBodyFontColor = \
                    os.environ['PODCAST_STATS_HTML_EMAIL_BODY_FONT_COLOR']
            else:
                self.strPodcastStatsHtmlEmailBodyFontColor = "_default_"
             
        self.strPodcastStatsHtmlEmailBodyFontColor = \
            self.strPodcastStatsHtmlEmailBodyFontColor.lower()
                
        if self.strPodcastStatsHtmlEmailBodyFontColor != "_default_":
            if not self._ValidateRgbInputParameter( \
                self.strPodcastStatsHtmlEmailBodyFontColor):
                raise Exception( \
                    "PODCAST_STATS_HTML_EMAIL_BODY_FONT_COLOR value is \
invalid.")        
    
       
        ###################################################################
        #Get NON_DOWNLOAD_ENTRY_PODCAST_LOG_AWS_S3_BUCKET_OBJECTS_DELETION.
        ###################################################################
        if len(sys.argv) > 1:
            #Get the setting from the command parameter.
            self.bNonDownloadEntryPodcastLogAwsS3BucketObjectsDeletion = \
                sys.argv[22]
        else:
            #Get the setting from the environment variable.
            if "NON_DOWNLOAD_ENTRY_PODCAST_LOG_AWS_S3_BUCKET_OBJECTS_DELETION" \
                in os.environ:
                self.bNonDownloadEntryPodcastLogAwsS3BucketObjectsDeletion = \
                    os.environ[ \
                    'NON_DOWNLOAD_ENTRY_PODCAST_LOG_AWS_S3_BUCKET_OBJECTS_DELETION']
            else:
                self.bNonDownloadEntryPodcastLogAwsS3BucketObjectsDeletion = \
                    "True"
                
        if self.bNonDownloadEntryPodcastLogAwsS3BucketObjectsDeletion == "True":
            self.bNonDownloadEntryPodcastLogAwsS3BucketObjectsDeletion = True
        elif self.bNonDownloadEntryPodcastLogAwsS3BucketObjectsDeletion == \
            "False":
            self.bNonDownloadEntryPodcastLogAwsS3BucketObjectsDeletion = False
        else:
            raise Exception( \
                "NON_DOWNLOAD_ENTRY_PODCAST_LOG_AWS_S3_BUCKET_OBJECTS_DELETION \
value is invalid.")
            
          
        #######################################################################
        #Get 
        #IRRELEVANT_DOWNLOAD_ENTRY_PODCAST_LOG_AWS_S3_BUCKET_OBJECTS_DELETION.
        #######################################################################
        if len(sys.argv) > 1:
            #Get the setting from the command parameter.
            self.bIrrelevantDownloadEntryPodcastLogAwsS3BucketObjectsDeletion \
                = sys.argv[23]
        else:
            #Get the setting from the environment variable.
            if "IRRELEVANT_DOWNLOAD_ENTRY_PODCAST_LOG_AWS_S3_BUCKET_OBJECTS_DELETION" \
                in os.environ:
                self.bIrrelevantDownloadEntryPodcastLogAwsS3BucketObjectsDeletion \
                    = os.environ[ \
                    'IRRELEVANT_DOWNLOAD_ENTRY_PODCAST_LOG_AWS_S3_BUCKET_OBJECTS_DELETION']
            else:
                self.bIrrelevantDownloadEntryPodcastLogAwsS3BucketObjectsDeletion \
                    = "True"
                
        if self.bIrrelevantDownloadEntryPodcastLogAwsS3BucketObjectsDeletion \
            == "True":
            self.bIrrelevantDownloadEntryPodcastLogAwsS3BucketObjectsDeletion \
                = True
        elif self.bIrrelevantDownloadEntryPodcastLogAwsS3BucketObjectsDeletion \
            == "False":
            self.bIrrelevantDownloadEntryPodcastLogAwsS3BucketObjectsDeletion \
                = False
        else:
            raise Exception( \
            "IRRELEVANT_DOWNLOAD_ENTRY_PODCAST_LOG_AWS_S3_BUCKET_OBJECTS_DELETION \
value is invalid.")
            
         
        ########################################################################
        #Get RELEVANT_DOWNLOAD_ENTRY_PODCAST_LOG_AWS_S3_BUCKET_OBJECTS_DELETION.
        ########################################################################
        if len(sys.argv) > 1:
            #Get the setting from the command parameter.
            self.bRelevantDownloadEntryPodcastLogAwsS3BucketObjectsDeletion = \
                sys.argv[24]
        else:
            #Get the setting from the environment variable.
            if "RELEVANT_DOWNLOAD_ENTRY_PODCAST_LOG_AWS_S3_BUCKET_OBJECTS_DELETION" \
                in os.environ:
                self.bRelevantDownloadEntryPodcastLogAwsS3BucketObjectsDeletion \
                = os.environ[ \
                'RELEVANT_DOWNLOAD_ENTRY_PODCAST_LOG_AWS_S3_BUCKET_OBJECTS_DELETION']
            else:
                self.bRelevantDownloadEntryPodcastLogAwsS3BucketObjectsDeletion \
                    = "True"
                
        if self.bRelevantDownloadEntryPodcastLogAwsS3BucketObjectsDeletion \
            == "True":
            self.bRelevantDownloadEntryPodcastLogAwsS3BucketObjectsDeletion \
                = True
        elif self.bRelevantDownloadEntryPodcastLogAwsS3BucketObjectsDeletion \
            == "False":
            self.bRelevantDownloadEntryPodcastLogAwsS3BucketObjectsDeletion \
                = False
        else:
            raise Exception( \
            "RELEVANT_DOWNLOAD_ENTRY_PODCAST_LOG_AWS_S3_BUCKET_OBJECTS_DELETION\
 value is invalid.")
       
            
        ###################################
        #Get PODCAST_STATS_REPORT_LANGUAGE.
        ###################################
        if len(sys.argv) > 1:
            #Get the setting from the command parameter.
            self.strPodcastStatsReportLanguage = sys.argv[25]
        else:
            #Get the setting from the environment variable.
            if "PODCAST_STATS_REPORT_LANGUAGE" in os.environ:
                self.strPodcastStatsReportLanguage = \
                    os.environ['PODCAST_STATS_REPORT_LANGUAGE']
            else:
                self.strPodcastStatsReportLanguage = "English"
                
        if self.strPodcastStatsReportLanguage not in \
            self.str_tuplePodcastStatsReportSupportedLanguages:
            raise Exception("PODCAST_STATS_REPORT_LANGUAGE value is invalid.")

            
    def _GetAwsS3ObjectContentInUtf8(self, s3_objectToRead):
        try:
            dictS3ObjectGetResponse = s3_objectToRead.get()
            dictS3ObjectGetResponse['Body'].set_socket_timeout(60)
            bytesS3ObjectBody = dictS3ObjectGetResponse['Body'].read()
            dictS3ObjectGetResponse['Body'].close()
        except botocore.exceptions.ClientError as exc:
            raise Exception("Failure to read the content of the AWS S3 object, " \
                + s3_objectToRead.key + " in " + s3_objectToRead.bucket_name \
                + ".\n\n" + str(exc))
        else:
            strS3PodcastLog = bytesS3ObjectBody.decode("utf-8")
            return strS3PodcastLog, \
                dictS3ObjectGetResponse['ResponseMetadata']['RetryAttempts']
         
            
    def _ProcessPodcastLogContent(self, strAwsS3PodcastLog):
        """
        Inputs
        ------
        strAwsS3PodcastLog (the function input parameter)
       
        
        Outputs
        -------
        self.bNonDownloadEntryPodcastLogAwsS3BucketObject
        self.bIrrelevantDownloadEntryPodcastLogAwsS3BucketObject
        self.bRelevantDownloadEntryPodcastLogAwsS3BucketObject
        
        self.bFutureEntryPodcastLogAwsS3BucketObject
        
        updated self.dictDatesToPodcastNameListsForCurrentPodcastLog
        
        updated self.dictDatesToPodcastNamesToDailyPodcastDownloadStatsDicts
        """
        
        for strS3PodcastLogEntry in strAwsS3PodcastLog.split('\n'):
            if strS3PodcastLogEntry == "": continue
    
            ###################################################################
            #Parse the podcast-log entry
            ###################################################################
            regexp_match_objS3PodcastLogEntry = \
                self.regexp_objPodcastLogEntryParser.search( \
                strS3PodcastLogEntry)
                               
            if regexp_match_objS3PodcastLogEntry == None:
                #raise Exception('Error while parsing a podcast log.  The \
#format of a podcast-log entry is invalid.\n' + strS3PodcastLogEntry)
                print('Error while parsing a podcast log.  The \
format of a podcast-log entry is invalid.\n' + strS3PodcastLogEntry)
                self.bNonDownloadEntryPodcastLogAwsS3BucketObject = True
                continue
                
                
            ###################################################################
            #If this is a non-download podcast log entry, mark this podcast log
            #AWS S3 object as non-download podcast log, and skip any further
            #processing (since there's no podcast download stats to record).
            ###################################################################
            strPodcastLogEntryOperationType = \
                regexp_match_objS3PodcastLogEntry.group(7)
                            
            strPodcastLogEntryHttpStatusResponseCode = \
                regexp_match_objS3PodcastLogEntry.group(12)
            
            if strPodcastLogEntryOperationType != "REST.GET.OBJECT"  or \
                (strPodcastLogEntryOperationType == "REST.GET.OBJECT" and \
                strPodcastLogEntryHttpStatusResponseCode[0] == '4'):
                self.bNonDownloadEntryPodcastLogAwsS3BucketObject = True
                continue
            
            
            ###################################################################
            #If this is an irrelevant-download podcast log entry, mark this 
            #podcast log AWS S3 object as irrelevant-download podcast log, and 
            #skip any further processing (since there's no podcast download 
            #stats to record).
            ###################################################################
            strPodcastLogEntryAwsS3ObjectKey = \
                regexp_match_objS3PodcastLogEntry.group(8)
            if strPodcastLogEntryAwsS3ObjectKey[0] == '/':
                strPodcastLogEntryAwsS3ObjectKey = \
                    strPodcastLogEntryAwsS3ObjectKey[1:]
            if strPodcastLogEntryAwsS3ObjectKey[-1] == '/':
                strPodcastLogEntryAwsS3ObjectKey = \
                    strPodcastLogEntryAwsS3ObjectKey[:-1]        
            
            strPodcastLogEntryAwsS3BucketName = \
                regexp_match_objS3PodcastLogEntry.group(2)
            if strPodcastLogEntryAwsS3BucketName == '':
                raise Exception('Error while parsing a podcast log.  The \
bucket name in the podcast-log entry is empty.\n' + strS3PodcastLogEntry)            
            
            str_listPodcastLogAwsS3ObjectKey = \
                strPodcastLogEntryAwsS3ObjectKey.split('/')
            strPodcastLogAwsS3ObjectFullName = \
                str_listPodcastLogAwsS3ObjectKey[-1]
            strPodcastLogAwsS3ObjectPrefix = \
                '/'.join(str_listPodcastLogAwsS3ObjectKey[0:-1])
                
            strAwsS3ObjectFolderPath = strPodcastLogEntryAwsS3BucketName
            if strPodcastLogAwsS3ObjectPrefix != '':
                strAwsS3ObjectFolderPath += '/' + \
                strPodcastLogAwsS3ObjectPrefix
                
            if strAwsS3ObjectFolderPath not in \
                self.str_listPodcastEpisodeAwsS3BucketFolderPaths:
                self.bIrrelevantDownloadEntryPodcastLogAwsS3BucketObject = True
                continue
            
            
            ###################################################################
            #This is a relevant-download podcast log entry,
            #since it is not an irrelevant-download podcast log entry.
            #Mark this podcast log entry as relevant-download (for podcast-log
            #deletion purpose).
            ###################################################################
            self.bRelevantDownloadEntryPodcastLogAwsS3BucketObject = True
            
            
            ###################################################################
            #If this is a future-download podcast log entry, mark this podcast
            #log AWS S3 object as future-download podcast log, and skip any
            #further processing (since there's no podcast download stats to 
            #record).
            ###################################################################
            strPodcastLogEntryDateTime = \
                regexp_match_objS3PodcastLogEntry.group(3)
            try:
                datetimePodcastLogEntry = datetime.datetime.strptime( \
                    strPodcastLogEntryDateTime, "%d/%b/%Y:%H:%M:%S %z")
            except:
                raise Exception('Error while parsing a podcast log.  The \
format of the date in a podcast-log entry is invalid.\n' \
                    + strS3PodcastLogEntry)            
            datePodcastLogEntry = datetimePodcastLogEntry.date()  
            if datePodcastLogEntry >= self.dateToday:
                self.bFutureEntryPodcastLogAwsS3BucketObject = True
                continue
            
            
            ###################################################################
            #Update self.dictDatesToPodcastNameListsForCurrentPodcastLog,
            #if applicable.
            ###################################################################
            iZeroBasedPodcastEpisodeAwsS3BucketFolderPathIndex = \
                self.str_listPodcastEpisodeAwsS3BucketFolderPaths.index( \
                    strAwsS3ObjectFolderPath)
            
            strPodcastName = self.str_listPodcastNamesInStatsReports[ \
                iZeroBasedPodcastEpisodeAwsS3BucketFolderPathIndex]
            
            if datePodcastLogEntry not in \
                self.dictDatesToPodcastNameListsForCurrentPodcastLog:
                str_listPodcastNamesInCurrentPodcastLogForThisDate = []
                self.dictDatesToPodcastNameListsForCurrentPodcastLog[ \
                    datePodcastLogEntry] =  \
                    str_listPodcastNamesInCurrentPodcastLogForThisDate
            else:
                str_listPodcastNamesInCurrentPodcastLogForThisDate = \
                    self.dictDatesToPodcastNameListsForCurrentPodcastLog[ \
                        datePodcastLogEntry]
                    
            if strPodcastName not in \
                str_listPodcastNamesInCurrentPodcastLogForThisDate:
                str_listPodcastNamesInCurrentPodcastLogForThisDate.append( \
                    strPodcastName)
            
            
            ###################################################################
            #Update the applicable podcast-download stat in
            #self.dictDatesToPodcastNamesToDailyPodcastDownloadStatsDicts.
            ################################################################### 
            
            #Get dictPodcastNamesToPodcastDownloadStatsDicts.
            if datePodcastLogEntry in \
                self.dictDatesToPodcastNamesToDailyPodcastDownloadStatsDicts:
                dictPodcastNamesToPodcastDownloadStatsDicts = \
                    self.dictDatesToPodcastNamesToDailyPodcastDownloadStatsDicts[ \
                        datePodcastLogEntry]
            else:
                dictPodcastNamesToPodcastDownloadStatsDicts = {}
                self.dictDatesToPodcastNamesToDailyPodcastDownloadStatsDicts[ \
                    datePodcastLogEntry] = \
                    dictPodcastNamesToPodcastDownloadStatsDicts
                                          
            #Get dictPodcastDownloadStats.
            if strPodcastName in dictPodcastNamesToPodcastDownloadStatsDicts:
                dictPodcastDownloadStats = \
                    dictPodcastNamesToPodcastDownloadStatsDicts[strPodcastName]
            else:
                dictPodcastDownloadStats = {}
                dictPodcastNamesToPodcastDownloadStatsDicts[strPodcastName] = \
                    dictPodcastDownloadStats
            
            #Update the podcast-episode download count.
            strPodcastEpisodeFileName = strPodcastLogAwsS3ObjectFullName
            
            if strPodcastEpisodeFileName in dictPodcastDownloadStats:
                dictPodcastDownloadStats[strPodcastEpisodeFileName] += 1
            else:
                dictPodcastDownloadStats[strPodcastEpisodeFileName] = 1    
        
            
    def _ProcessPodcastLogs(self, strPodcastLogAwsS3BucketFolderPath):
        #PRECONDITION(S)
        #---------------
        #The podcast-log AWS S3 bucket folder paths passed to this function
        #must not result in redundant podcast log processing.
        #
        #INPUT(S)
        #--------
        #The podcast-log AWS S3 objects in the location specified by the input
        #parameter strPodcastLogAwsS3BucketFolderPath.
        #strPodcastLogAwsS3BucketFolderPath must not start or end in /.
        #
        #OUTPUT(S)
        #---------
        #Updated self.dictDatesToPodcastNamesToDailyPodcastDownloadStatsDicts.
        #Updated self.dictDatesToTotalNumbersOfPodcastLogAwsS3Objects.
        #Updated self.dictDatesToPodcastNamesToPodcastLogCounts.
        #Updated self.dictDatesToPodcastNamesToPodcastLogAccessRetryCounts.
        #Updated self.dictPodcastLogAwsS3BucketNamesToDeletionPodcastLogAwsS3ObjectKeyLists.
        #
        #FUNCTIONALITY
        #-------------
        #This function processes the podcast-log AWS S3 object contents to  
        #generate daily podcast-download stats, podcast-log stats (count and 
        #retry error), and podcast-log deletion list(s).
        #
        #If there's any applicable podcast-log entry
        #(i.e. relevant podcast episode download log entry), the content of 
        #self.dictDatesToPodcastNamesToDailyPodcastDownloadStatsDicts,
        #self.dictDatesToTotalNumbersOfPodcastLogAwsS3Objects,
        #self.dictDatesToPodcastNamesToPodcastLogCounts, and
        #self.dictDatesToPodcastNamesToPodcastLogAccessRetryCounts will have 
        #been updated after calling this function.
        #
        #If applicable,
        #self.dictPodcastLogAwsS3BucketNamesToDeletionPodcastLogAwsS3ObjectKeyLists
        #will have been updated after calling this function.
        #
        #This function does not generate weekly and monthly podcast stats.
        #Those stats are generated elsewhere by other functions.
     
        
        #######################################################################
        #Using the relevant program settings and boto3 API, acquire the AWS S3
        #objects to process.
        #######################################################################
        str_listPodcastLogAwsS3BucketFolderPath = \
            strPodcastLogAwsS3BucketFolderPath.split('/', 1)
        strPodcastLogS3BucketName = str_listPodcastLogAwsS3BucketFolderPath[0]
        
        if strPodcastLogS3BucketName in \
            self.dictPodcastLogAwsS3BucketNamesToDeletionPodcastLogAwsS3ObjectKeyLists:
            str_listDeletionPodcastLogAwsS3ObjectKeys = \
                self.dictPodcastLogAwsS3BucketNamesToDeletionPodcastLogAwsS3ObjectKeyLists[ \
                strPodcastLogS3BucketName]
        else:
            str_listDeletionPodcastLogAwsS3ObjectKeys = []
            self.dictPodcastLogAwsS3BucketNamesToDeletionPodcastLogAwsS3ObjectKeyLists[ \
                strPodcastLogS3BucketName] = \
                str_listDeletionPodcastLogAwsS3ObjectKeys
        #The above code requires enforcing during the input validation that                                                                       
        #the podcast-log AWS S3 bucket folder paths passed to this function
        #must not result in redundant podcast log processing.                                                                            
    
        s3_bucketPodcastLogs = \
            self.s3_resource.Bucket(strPodcastLogS3BucketName)
        
        if len(str_listPodcastLogAwsS3BucketFolderPath) == 1:
            iteratorPodcastLogAwsS3Objects = s3_bucketPodcastLogs.objects.all()
        else:
            iteratorPodcastLogAwsS3Objects = \
                s3_bucketPodcastLogs.objects.filter( \
                Prefix=str_listPodcastLogAwsS3BucketFolderPath[1] + '/')
        
        
        #######################################################################
        #Process the content of each AWS S3 object in 
        #strPodcastLogAwsS3BucketFolderPath to produce the required outputs.
        #######################################################################    
        for s3_objectPodcastLog in iteratorPodcastLogAwsS3Objects:
    
            if s3_objectPodcastLog.key[-1] == '/' and \
                s3_objectPodcastLog.size == 0:
                continue

            ###################################################################
            #Initialize the data variables used in processing each podcast log
            #AWS S3 object.
            ###################################################################
            self.bNonDownloadEntryPodcastLogAwsS3BucketObject = False
            self.bIrrelevantDownloadEntryPodcastLogAwsS3BucketObject = False
            self.bRelevantDownloadEntryPodcastLogAwsS3BucketObject = False
            
            self.bFutureEntryPodcastLogAwsS3BucketObject = False
            
            self.dictDatesToPodcastNameListsForCurrentPodcastLog = {}
            
            ###################################################################
            #Get the podcast-log AWS S3 object content.
            ###################################################################
            strAwsS3PodcastLog, iPodcastLogAwsS3ObjectReadRetryAttempts = \
                self._GetAwsS3ObjectContentInUtf8(s3_objectPodcastLog)
            
            ###################################################################
            #Process each line of the podcast-log AWS S3 object content.
            ###################################################################
            self._ProcessPodcastLogContent(strAwsS3PodcastLog)
    
            ###################################################################       
            #Update self.dictDatesToPodcastNamesToPodcastLogCounts,
            #self.dictDatesToPodcastNamesToPodcastLogAccessRetryCounts, and
            #self.dictDatesToTotalNumbersOfPodcastLogAwsS3Objects as 
            #applicable.  
            ###################################################################
            for datePodcastDownload, \
                str_listPodcastNamesInCurrentPodcastLogForThisDate in \
                self.dictDatesToPodcastNameListsForCurrentPodcastLog.items():
                
                if datePodcastDownload in \
                    self.dictDatesToPodcastNamesToPodcastLogCounts:
                    dictPodcastNamesToPodcastLogCounts = \
                        self.dictDatesToPodcastNamesToPodcastLogCounts[ \
                        datePodcastDownload]
                else:
                    dictPodcastNamesToPodcastLogCounts = {}
                    self.dictDatesToPodcastNamesToPodcastLogCounts[ \
                        datePodcastDownload] \
                        = dictPodcastNamesToPodcastLogCounts
                        
                if datePodcastDownload in \
                    self.dictDatesToPodcastNamesToPodcastLogAccessRetryCounts:
                    dictPodcastNamesToPodcastLogAccessRetryCounts = \
                        self.dictDatesToPodcastNamesToPodcastLogAccessRetryCounts[ \
                        datePodcastDownload]
                else:
                    dictPodcastNamesToPodcastLogAccessRetryCounts = {}
                    self.dictDatesToPodcastNamesToPodcastLogAccessRetryCounts[ \
                        datePodcastDownload] \
                        = dictPodcastNamesToPodcastLogAccessRetryCounts
                        
                        
                for strPodcastName in \
                    str_listPodcastNamesInCurrentPodcastLogForThisDate:
                    
                    if strPodcastName in dictPodcastNamesToPodcastLogCounts:
                        dictPodcastNamesToPodcastLogCounts[strPodcastName] += 1
                    else:
                        dictPodcastNamesToPodcastLogCounts[strPodcastName] = 1
                        
                    if strPodcastName in \
                        dictPodcastNamesToPodcastLogAccessRetryCounts:
                        dictPodcastNamesToPodcastLogAccessRetryCounts[ \
                            strPodcastName] += \
                            iPodcastLogAwsS3ObjectReadRetryAttempts
                    else:
                        dictPodcastNamesToPodcastLogAccessRetryCounts[ \
                            strPodcastName] = \
                            iPodcastLogAwsS3ObjectReadRetryAttempts
                            
                #NOTE: 
                #len(str_listPodcastNamesInCurrentPodcastLogForThisDate) > 0
                #is always True.
                if datePodcastDownload in \
                    self.dictDatesToTotalNumbersOfPodcastLogAwsS3Objects:
                        
                    self.dictDatesToTotalNumbersOfPodcastLogAwsS3Objects[ \
                        datePodcastDownload] += 1
                else:
                    self.dictDatesToTotalNumbersOfPodcastLogAwsS3Objects[ \
                        datePodcastDownload] = 1
                                                                         
                    
            #######################################################################
            #update
            #self.dictPodcastLogAwsS3BucketNamesToDeletionPodcastLogAwsS3ObjectKeyLists
            #as needed.
            #######################################################################
            if not self.bFutureEntryPodcastLogAwsS3BucketObject:
                if self.bNonDownloadEntryPodcastLogAwsS3BucketObject and not \
                    self.bNonDownloadEntryPodcastLogAwsS3BucketObjectsDeletion:
                    continue
                
                if self.bIrrelevantDownloadEntryPodcastLogAwsS3BucketObject \
                    and not \
                    self.bIrrelevantDownloadEntryPodcastLogAwsS3BucketObjectsDeletion:
                    continue
                
                if self.bRelevantDownloadEntryPodcastLogAwsS3BucketObject \
                    and not \
                    self.bRelevantDownloadEntryPodcastLogAwsS3BucketObjectsDeletion:
                    continue
                
                str_listDeletionPodcastLogAwsS3ObjectKeys.append( \
                    s3_objectPodcastLog.key)            
            
    
    def _EmailAndSavePodcastStats(self):
        """
        INPUTS
        ------
        self.dictDatesToPodcastNamesToDailyPodcastDownloadStatsDicts
        self.dictDatesToTotalNumbersOfPodcastLogAwsS3Objects
        self.dictDatesToPodcastNamesToPodcastLogCounts
        self.dictDatesToPodcastNamesToPodcastLogAccessRetryCounts
        
        OUTPUTS
        -------
        All the applicable podcast-stats emails generated and sent.
        All the applicable podcast-stats AWS S3 objects saved.
        """
        
        #######################################################################
        #Create and assign
        #self.dictPodcastNamesToPodcastEpisodeAwsS3BucketFolderPaths,
        #self.dictPodcastNamesToPodcastStatsAwsS3BucketFolderPaths and
        #self.dictPodcastNamesToPodcastStatsAwsS3BucketNameAndPrefixLists 
        #values.
        #######################################################################
        for iZeroBasedListItemIndex in \
            range(0, len(self.str_listPodcastNamesInStatsReports)):
                
            strPodcastName = \
                self.str_listPodcastNamesInStatsReports[ \
                    iZeroBasedListItemIndex]
                
                
            strPodcastEpisodeAwsS3BucketFolderPath = \
                self.str_listPodcastEpisodeAwsS3BucketFolderPaths[ \
                    iZeroBasedListItemIndex]            
                
            strPodcastStatsAwsS3BucketFolderPath = \
                self.str_listPodcastStatsAwsS3BucketFolderPaths[ \
                    iZeroBasedListItemIndex]
            str_listPodcastStatsAwsS3BucketFolderPath = \
                strPodcastStatsAwsS3BucketFolderPath.split('/', 1)
            strPodcastStatsAwsS3BucketName = \
                str_listPodcastStatsAwsS3BucketFolderPath[0]
            if len(str_listPodcastStatsAwsS3BucketFolderPath) == 1:
                strPodcastStatsAwsS3ObjectPrefix = ''
            else:
                strPodcastStatsAwsS3ObjectPrefix = \
                    str_listPodcastStatsAwsS3BucketFolderPath[1]
                
                
            self.dictPodcastNamesToPodcastEpisodeAwsS3BucketFolderPaths[ \
                strPodcastName] = strPodcastEpisodeAwsS3BucketFolderPath
                
            self.dictPodcastNamesToPodcastStatsAwsS3BucketFolderPaths[ \
                strPodcastName] = strPodcastStatsAwsS3BucketFolderPath
                
            self.dictPodcastNamesToPodcastStatsAwsS3BucketNameAndObjectPrefixLists[ \
                strPodcastName] = [strPodcastStatsAwsS3BucketName, \
                strPodcastStatsAwsS3ObjectPrefix]
                
        
        #######################################################################
        #Create a version of 
        #self.dictDatesToPodcastNamesToDailyPodcastDownloadStatsDicts
        #that is sorted by key (date range).
        #That is, sort the daily podcast-download stats or download-count 
        #dictionary by date (key), to email and save the podcast-download stats 
        #by ascending date order.
        #######################################################################
        tuple_listSortedDatesToPodcastNamesToDailyPodcastDownloadStatsDicts = \
            sorted(self.dictDatesToPodcastNamesToDailyPodcastDownloadStatsDicts.items())
        
        
        #######################################################################
        #Email and save the podcast stats for each date.
        #######################################################################
        bYesterdaysDailyPodcastStatsReported = False
        
        for tupleDateToPodcastNamesToDailyPodcastDownloadStatsDicts in \
            tuple_listSortedDatesToPodcastNamesToDailyPodcastDownloadStatsDicts:
    
            self.dateCurrentPodcastDownload = \
                tupleDateToPodcastNamesToDailyPodcastDownloadStatsDicts[0]
            self.dictPodcastNamesToDailyPodcastDownloadStatsDicts = \
                tupleDateToPodcastNamesToDailyPodcastDownloadStatsDicts[1]
                
            if self.dateCurrentPodcastDownload == self.dateYesterday:
                bYesterdaysDailyPodcastStatsReported = True
    
    
            ###################################################################
            #Execute the daily podcast-stats emailing and AWS S3 objects 
            #saving, if the daily podcast-stats AWS S3 object(s) do not already 
            #exist.
            ###################################################################
            self._ReportDailyPodcastStats()
    
    
            ###################################################################
            #Execute the weekly podcast-stats emailing and AWS S3 objects 
            #saving, if the weekly podcast-stats AWS S3 object(s) do not 
            #already exist.
            ###################################################################
            self._ReportWeeklyPodcastStats()           
    
    
            ###################################################################
            #Execute the monthly podcast-stats emailing and AWS S3 objects 
            #saving, if the monthly podcast-stats AWS S3 object(s) do not 
            #already exist.
            ###################################################################
            self._ReportMonthlyPodcastStats()
          
    
        #######################################################################
        #If there was no podcast download yesterday (the latest day of 
        #reporting in this reporting instance),
        #self._ReportDailyPodcastStats(), self._ReportWeeklyPodcastStats() and 
        #self._ReportMonthlyPodcastStats()  was not executed above for 
        #yesterday.
        #However, they still need to be called on applicable dates.
        #Handle such cases below.
        #######################################################################
        
        #######################################################################
        #Call self._ReportDailyPodcastStats() if applicable.
        #######################################################################
        if bYesterdaysDailyPodcastStatsReported: return

        self.dateCurrentPodcastDownload = self.dateYesterday
        
        self.dictDatesToTotalNumbersOfPodcastLogAwsS3Objects[ \
            self.dateCurrentPodcastDownload] = 0 
                                    
        dictPodcastNamesToPodcastLogCounts = {}                                            
        self.dictDatesToPodcastNamesToPodcastLogCounts[ \
            self.dateCurrentPodcastDownload] = \
            dictPodcastNamesToPodcastLogCounts
        
        dictPodcastNamesToPodcastLogAccessRetryCounts = {}
        self.dictDatesToPodcastNamesToPodcastLogAccessRetryCounts[ \
            self.dateCurrentPodcastDownload] = \
            dictPodcastNamesToPodcastLogAccessRetryCounts
        
        
        self.dictPodcastNamesToDailyPodcastDownloadStatsDicts = {}
        for strPodcastName in self.str_listPodcastNamesInStatsReports:
            self.dictPodcastNamesToDailyPodcastDownloadStatsDicts[ \
                strPodcastName] = {}
            
            dictPodcastNamesToPodcastLogCounts[strPodcastName] = 0
            dictPodcastNamesToPodcastLogAccessRetryCounts[strPodcastName] \
                = 0
    
    
        self._ReportDailyPodcastStats()
        
        
        #######################################################################
        #Call self._ReportWeeklyPodcastStats() if applicable.
        #######################################################################
        if self.dateYesterday.weekday() == 6: #Sunday
            
            self.dateCurrentPodcastDownload = self.dateYesterday
           
            ###################################################################
            #Execute the weekly podcast-stats emailing and AWS S3 objects 
            #saving, if the weekly podcast-stats AWS S3 object(s) do not 
            #already exist.
            ###################################################################
            self._ReportWeeklyPodcastStats()           
    
    
        #######################################################################
        #Call self._ReportMonthlyPodcastStats() if applicable.
        #######################################################################
        iZeroBasedMonthFirstDayWeekday, iNumberOfDaysInMonth = \
            calendar.monthrange(self.dateYesterday.year, \
                self.dateYesterday.month)
        if self.dateYesterday.day == iNumberOfDaysInMonth: #end of the month
                    
            self.dateCurrentPodcastDownload = self.dateYesterday
        
            ###################################################################
            #Execute the monthly podcast-stats emailing and AWS S3 objects 
            #saving, if the monthly podcast-stats AWS S3 object(s) do not 
            #already exist.
            ###################################################################
            self._ReportMonthlyPodcastStats()
            
    
    def _CheckAllPodcastStatsAwsS3ObjectExistences(self):
        """
        INPUTS
        ------
        self.str_listPodcastNamesInStatsReports
        self.strDateRange
        self.dictPodcastNamesToPodcastStatsAwsS3BucketNameAndObjectPrefixLists
        self.dictPodcastNamesToPodcastEpisodeAwsS3BucketFolderPaths
        
        OUTPUT
        ------
        self.str_listMissingPodcastStatsAwsS3ObjectPodcastNames
        self.str_list_listMissingPodcastStatsAwsS3ObjectBucketNameAndObjectKeyLists
        
        This function returns True, if all the podcast-stats AWS S3 objects 
        exist for all the podcasts, for self.strDateRange.
        Otherwise, it returns False.
        
        FUNCTIONALITY
        -------------
        This function checks the podcast-stats AWS S3 object existence for
        every podcast, for self.strDateRange.
        
        This function calls self._GetPodcastStatsAwsS3BucketNameAndObjectKey() 
        and self._CheckAwsS3ObjectExistence(), in order to verify 
        podcast-stats AWS S3 object
        existences.
        
        This function initializes and builds
        self.str_listMissingPodcastStatsAwsS3ObjectPodcastNames and
        self.str_list_listMissingPodcastStatsAwsS3ObjectBucketNameAndObjectKeyLists
        """
        
        
        strResult = True
        
        self.str_listMissingPodcastStatsAwsS3ObjectPodcastNames = []
        self.str_list_listMissingPodcastStatsAwsS3ObjectBucketNameAndObjectKeyLists \
            = []
        
        if self.strDateRangeType == 'daily':
            str_listPodcastNames =  list( \
                self.dictPodcastNamesToDailyPodcastDownloadStatsDicts.keys())
        else:
            str_listPodcastNames = self.str_listPodcastNamesInStatsReports        
        
        for self.strCurrentPodcastName in str_listPodcastNames:
    
            self._GetPodcastStatsAwsS3BucketNameAndObjectKey()
        
            if not self._CheckAwsS3ObjectExistence():
                self.str_listMissingPodcastStatsAwsS3ObjectPodcastNames.append( \
                    self.strCurrentPodcastName)
                self.str_list_listMissingPodcastStatsAwsS3ObjectBucketNameAndObjectKeyLists.append( \
                    [self.strCurrentPodcastStatsAwsS3BucketName, \
                     self.strCurrentPodcastStatsAwsS3ObjectKey])
                strResult = False
        
        return strResult
    
    
    def _GetPodcastStatsAwsS3BucketNameAndObjectKey(self):
        """
        INPUTS
        ------
        self.strCurrentPodcastName
        self.strDateRange
        self.dictPodcastNamesToPodcastStatsAwsS3BucketNameAndObjectPrefixLists
        self.dictPodcastNamesToPodcastEpisodeAwsS3BucketFolderPaths
        
        
        OUTPUT
        ------
        self.strCurrentPodcastStatsAwsS3BucketName
        self.strCurrentPodcastStatsAwsS3ObjectPrefix
        self.strCurrentPodcastStatsAwsS3ObjectKey
            Each podcast-stat AWS S3 object name has the podcast-episode AWS 
            S3 folder path with / replaced with _, a space, and the date range
            (YYYY-MM-DD if day stats, or starting YYYY-MM-DD, a space, ending
            YYYY-MM-DD, if week or month stats).
            
            Note that each podcast-stats AWS S3 object key is guaranteed to be
            unique, since each podcast-episode AWS S3 folder path and date 
            range used in the AWS S3 object key is unique.
        """
            
    
        str_listPodcastStatsAwsS3BucketNameAndObjectPrefix = \
            self.dictPodcastNamesToPodcastStatsAwsS3BucketNameAndObjectPrefixLists[ \
                self.strCurrentPodcastName]
            
        self.strCurrentPodcastStatsAwsS3BucketName = \
            str_listPodcastStatsAwsS3BucketNameAndObjectPrefix[0]
        self.strCurrentPodcastStatsAwsS3ObjectPrefix = \
            str_listPodcastStatsAwsS3BucketNameAndObjectPrefix[1]
    
            
        strPodcastEpisodeAwsS3BucketFolderPath = \
            self.dictPodcastNamesToPodcastEpisodeAwsS3BucketFolderPaths[ \
                self.strCurrentPodcastName]
            
        if self.strCurrentPodcastStatsAwsS3ObjectPrefix == '':
            self.strCurrentPodcastStatsAwsS3ObjectKey = \
                strPodcastEpisodeAwsS3BucketFolderPath.replace('/', '_') + ' ' \
                + self.strDateRange
        else:
            self.strCurrentPodcastStatsAwsS3ObjectKey = \
                self.strCurrentPodcastStatsAwsS3ObjectPrefix + '/' + \
                strPodcastEpisodeAwsS3BucketFolderPath.replace('/', '_') + ' ' \
                + self.strDateRange
        
    
    def _CheckAwsS3ObjectExistence(self):
        """
        INPUTS
        ------
        self.strCurrentPodcastStatsAwsS3BucketName
        self.strCurrentPodcastStatsAwsS3ObjectKey
        
        
        OUTPUT
        ------
        returns True if the AWS S3 object exists.
        returns False if the AWS S3 object doesn't exist.
        """
        
        
        try:
            self.s3_resource.Object(self.strCurrentPodcastStatsAwsS3BucketName,
                self.strCurrentPodcastStatsAwsS3ObjectKey).load()
        except botocore.exceptions.ClientError as exc:
            if exc.response['Error']['Code'] == "404":
                #The object does not exist.
                return False
            else:
                #Something else has gone wrong.
                raise Exception( \
                    'Error while querying an AWS S3 object existence.  ' + \
                    self.strCurrentPodcastStatsAwsS3BucketName + \
                    self.strCurrentPodcastStatsAwsS3ObjectKey + '\n' + \
                    str(exc))
        else:
            #The object does exist.
            return True
        
    
    def _EmailPodcastStats(self):
        """
        INPUTS
        ------
        self.dateReportPeriodStart
        self.dateReportPeriodEnd
        self.strDateRangeType
        self.strEmailTitleHead
        self.str_listMissingPodcastStatsAwsS3ObjectPodcastNames
    
        self.dictPodcastNamesToDailyPodcastDownloadStatsDicts
        
        self.dictDatesToTotalNumbersOfPodcastLogAwsS3Objects
        self.dictDatesToPodcastNamesToPodcastLogCounts
        self.dictDatesToPodcastNamesToPodcastLogAccessRetryCounts
        
    
        OUTPUTS
        -------
        All the daily, weekly, or monthly emails of the current date
        generated and sent.
        
        
        IMPLEMENTATION TECHNIQUE
        ------------------------
        Create the email and AWS S3 object contents using a string list
        and '\n'.join(str_listContent), to create text in the most sensible 
        way (i.e. fast to code, reasonably fast in execution).
        """
        
        if len(self.str_listMissingPodcastStatsAwsS3ObjectPodcastNames) == 0:
            return        
        
        #Initialize self.dictPodcastNamesToPodcastStatsEmailSendingRetryCounts
        #for use in all cases.
        for strPodcastName in \
            self.str_listMissingPodcastStatsAwsS3ObjectPodcastNames:
            self.dictPodcastNamesToPodcastStatsEmailSendingRetryCounts[ \
                strPodcastName] = -1         
        
        self._CalculateTotalDownloadCountsInDateRange()
        
        if self.bSeparatePodcastStatsEmails:
            for self.strCurrentPodcastName in \
                self.str_listMissingPodcastStatsAwsS3ObjectPodcastNames:
                
                self._AssignPodcastStatsClassMemberDataVariablesForEmailing()
                    
                self.strEmailTitle = self.strEmailTitleHead + \
                    "podcast download stats for " + self.strCurrentPodcastName
                    
                self._GenerateEmailBodyForSinglePodcast()
                
                self._SendEmail()
        else:
            #Do not send the merged or multi-podcast email, if one or more 
            #required podcast-stats AWS S3 object is present, which indicates 
            #that the email was sent successfully before, and at least one
            #podcast-stats AWS S3 object was saved.
            #That is, send the merged or multi-podcast email, only when
            #every required podcast-stats AWS S3 object is missing.
            if self.strDateRangeType == 'daily':
                if len(self.str_listMissingPodcastStatsAwsS3ObjectPodcastNames) \
                    != len( \
                    self.dictPodcastNamesToDailyPodcastDownloadStatsDicts):
                    return
            else: #'weekly' and 'monthly' 
                if len(self.str_listMissingPodcastStatsAwsS3ObjectPodcastNames) \
                    != len(self.str_listPodcastNamesInStatsReports):
                    return
                    

            self.strEmailTitle = self.strEmailTitleHead + \
                "podcast download stats"
                
            self._GenerateEmailBodyForMultiplePodcasts()
            
            self._SendEmail()    
    
    
    def _AssignPodcastStatsClassMemberDataVariablesForEmailing(self):       
        
        if self.strDateRangeType == 'daily':
            self.dictPodcastDownloadStats = \
                self.dictPodcastNamesToDailyPodcastDownloadStatsDicts[ \
                    self.strCurrentPodcastName]
        else:
            if self.strDateRangeType == 'weekly':
                self.dictPodcastDownloadStats = \
                    self.dictEndingDatesToPodcastNamesToWeeklyPodcastDownloadStatsDicts[ \
                    self.dateCurrentPodcastDownload][ \
                    self.strCurrentPodcastName]
            else: #monthly
                self.dictPodcastDownloadStats = \
                    self.dictEndingDatesToPodcastNamesToMonthlyPodcastDownloadStatsDicts[ \
                    self.dateCurrentPodcastDownload][ \
                    self.strCurrentPodcastName]
                
            tupleDateRange = (self.dateReportPeriodStart, \
                self.dateReportPeriodEnd)
            self.iNumberOfMissingDaysFromThisWeeklyOrMonthlyPodcastStatsReport \
                = self.dictPodcastNamesToDateRangesToMissingDayCounts[ \
                    self.strCurrentPodcastName][tupleDateRange]
            self.iTotalNumberOfPodcastStatsAwsS3ObjectAccessRetriesInThisWeeklyOrMonthlyPodcastStatsReport \
                = self.dictPodcastNamesToDateRangesToPodcastStatsAwsS3ObjectAccessRetryCounts[ \
                    self.strCurrentPodcastName][tupleDateRange]
            self.strCommaSeparatedListOfMissingDailyPodcastStatsAwsS3Objects \
                = self.dictPodcastNamesToDateRangesToMissingDailyPodcastStatsAwsS3ObjectCommaSeparatedListStrings[ \
                    self.strCurrentPodcastName][tupleDateRange]
    
    
    def _CalculateTotalDownloadCountsInDateRange(self):
        tupleDateRange = (self.dateReportPeriodStart, self.dateReportPeriodEnd)
        
        if self.strDateRangeType == 'daily':
            dictPodcastNamesToPodcastDownloadStatsDicts = \
                self.dictPodcastNamesToDailyPodcastDownloadStatsDicts
        elif self.strDateRangeType == 'weekly':
            dictPodcastNamesToPodcastDownloadStatsDicts = \
                self.dictEndingDatesToPodcastNamesToWeeklyPodcastDownloadStatsDicts[ \
                    self.dateCurrentPodcastDownload]  
        else: #'monthly'
            dictPodcastNamesToPodcastDownloadStatsDicts = \
                self.dictEndingDatesToPodcastNamesToMonthlyPodcastDownloadStatsDicts[ \
                    self.dateCurrentPodcastDownload]        

            
        #Calculate the total number of podcast episode downloads from all 
        #podcasts (during this period).
        iTotalNumberOfPodcastEpisodeDownloadsDuringThisPeriod = 0
        
        for dictPodcastDownloadStats in \
            dictPodcastNamesToPodcastDownloadStatsDicts.values():       
        
            for iDownloadCount in dictPodcastDownloadStats.values():
                iTotalNumberOfPodcastEpisodeDownloadsDuringThisPeriod += \
                iDownloadCount
                
        self.dictDateRangesToTotalDownloadCounts[tupleDateRange] = \
            iTotalNumberOfPodcastEpisodeDownloadsDuringThisPeriod
            
    
    def _CreateHeadElementOfHtmlEmail(self):
        """
        INPUTS
        ------
        self.strEmailTitle
        
        OUTPUTS
        -------
        str_listHtmlEmailBody (the returned data variable)
        """
    
        
        str_listHtmlEmailBody = []
        
        str_listHtmlEmailBody.append('<!DOCTYPE html PUBLIC "-//W3C//DTD \
XHTML 1.0 Transitional//EN" \
"https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">')
        str_listHtmlEmailBody.append('<html \
xmlns="https://www.w3.org/1999/xhtml">')
        str_listHtmlEmailBody.append('<head>')
        str_listHtmlEmailBody.append('<title>' + self.strEmailTitle + \
                                     '</title>')
        str_listHtmlEmailBody.append('<meta http-equiv="Content-Type" \
content="text/html; charset=UTF-8" />')
        str_listHtmlEmailBody.append('<meta http-equiv="X-UA-Compatible" \
content="IE=edge" />')
        str_listHtmlEmailBody.append('<meta name="viewport" \
content="width=device-width, initial-scale=1.0 " />')
        str_listHtmlEmailBody.append('<style>')
        
        str_listHtmlEmailBody.append('body {margin: 0; padding: 0;}')

        if self.strPodcastStatsHtmlEmailBackdropColor != "_default_":
            str_listHtmlEmailBody.append( \
                'div.email_body {margin: 0; padding: 0; background-color: ' + \
                    self.strPodcastStatsHtmlEmailBackdropColor + ';}')
        else:
            str_listHtmlEmailBody.append( \
                'div.email_body {margin: 0; padding: 0;}')
    
        if self.strPodcastStatsHtmlEmailSectionHeadingBackdropColor != \
            "_default_":    
            str_listHtmlEmailBody.append( \
                'div.section_heading {margin: 0; padding: 0; background-color: ' \
                + self.strPodcastStatsHtmlEmailSectionHeadingBackdropColor + \
                ';}') 
        else:
            str_listHtmlEmailBody.append('div.section_heading {margin: 0; \
padding: 0;}') 
            
        strHtmlEmailSectionHeadingCss = \
            'h1.section_heading {text-align: center;'
        if self.strPodcastStatsHtmlEmailSectionHeadingFontName.lower() != \
            "_default_":
            strHtmlEmailSectionHeadingCss += ' font: ' + \
                self.strPodcastStatsHtmlEmailSectionHeadingFontName + ';'
        if self.strPodcastStatsHtmlEmailSectionHeadingFontSize.lower() != \
            "_default_":
            strHtmlEmailSectionHeadingCss += ' font-size: ' + \
                self.strPodcastStatsHtmlEmailSectionHeadingFontSize + ';'
        if self.strPodcastStatsHtmlEmailSectionHeadingFontColor.lower() != \
            "_default_":
            strHtmlEmailSectionHeadingCss += ' color: ' + \
                self.strPodcastStatsHtmlEmailSectionHeadingFontColor + ';'
        strHtmlEmailSectionHeadingCss += '}'
        str_listHtmlEmailBody.append(strHtmlEmailSectionHeadingCss) 
        
        strHtmlEmailBodyCss = 'p {'
        if self.strPodcastStatsHtmlEmailBodyFontName.lower() != "_default_":
            strHtmlEmailBodyCss += ' font: ' + \
                self.strPodcastStatsHtmlEmailBodyFontName + ';'
        if self.strPodcastStatsHtmlEmailBodyFontSize.lower() != "_default_":
            strHtmlEmailBodyCss += ' font-size: ' + \
                self.strPodcastStatsHtmlEmailBodyFontSize + ';'
        if self.strPodcastStatsHtmlEmailBodyFontColor.lower() != "_default_":
            strHtmlEmailBodyCss += ' color: ' + \
                self.strPodcastStatsHtmlEmailBodyFontColor + ';'
        strHtmlEmailBodyCss += '}'
        if strHtmlEmailBodyCss != 'p {}':
            str_listHtmlEmailBody.append(strHtmlEmailBodyCss) 
        
        if self.strPodcastStatsHtmlEmailBodyFontColor.lower() == "_default_":
            str_listHtmlEmailBody.append('table.podcast_download_stats {width: \
100%; border: 0; cellspacing: 0; cellpadding: 0;}')
        else:
            str_listHtmlEmailBody.append('table.podcast_download_stats {width: \
100%; border: 0; cellspacing: 0; cellpadding: 0; color: ' + \
                self.strPodcastStatsHtmlEmailBodyFontColor + ';}')
        str_listHtmlEmailBody.append('td.podcast_episode_name {width: 100%;}')
        str_listHtmlEmailBody.append( \
            'td.podcast_episode_download_count {width: 100%;}')
        
        str_listHtmlEmailBody.append('</style>')
        str_listHtmlEmailBody.append('</head>')
    
        return str_listHtmlEmailBody
    
    
    def _CreateEmailHeaderSection(self):
        #======================================================================
        #======================================================================
        #Stage 1 of 4
        #------------
        #Create the <head> element of the HTML section
        #======================================================================
        #======================================================================   
        self.str_listHtmlEmailBody = self._CreateHeadElementOfHtmlEmail()
        
        
        #======================================================================
        #======================================================================
        #Stage 2 of 4
        #------------
        #Create the header section
        #======================================================================
        #======================================================================
            
        #######################################################################
        #Create the header section heading with the proper section title
        #in plain-text and HTML.
        #######################################################################
    
        #Add the podcast stats report overview section heading,
        #with centered "Daily/Weekly/Monthly Podcast Stats Report" 
        
        #Add the HTML header section heading
        self.str_listHtmlEmailBody.append('<body>')
        self.str_listHtmlEmailBody.append('<div class="email_body">')
        self.str_listHtmlEmailBody.append('<div class="section_heading">')
        self.str_listHtmlEmailBody.append('<h1 class="section_heading">' + \
            self.strDateRangeType.capitalize() + ' Podcast Stats Report</h1>')
        self.str_listHtmlEmailBody.append('</div>')
        
        #Add the plain-text header section heading
        self.str_listPlainTextEmailBody = \
            [self.strDateRangeType.capitalize() + ' Podcast Stats Report',
            '==============================================']
        
        
        #######################################################################
        #Create the header section body with the podcast-stats overview
        #in plain-text and HTML.
        #######################################################################      
        tupleDateRange = (self.dateReportPeriodStart, self.dateReportPeriodEnd)
        iTotalNumberOfPodcastEpisodeDownloadsDuringThisPeriod = \
            self.dictDateRangesToTotalDownloadCounts[tupleDateRange]        
        
        #Add "Date (range):  (date [range])".    
        if self.strDateRangeType == 'daily':
            
            #Add "Total number of podcast episode downloads (during this 
            #period):  (number)".
            strPodcastEpisodeDownloadTotalNotice = eval( \
                self.dictLanguagesToAllPodcastsDailyDownloadCountDescriptors[ \
                self.strPodcastStatsReportLanguage])
                
            self.str_listHtmlEmailBody.append('<p>' + \
                strPodcastEpisodeDownloadTotalNotice + '</p>')
            self.str_listPlainTextEmailBody.append( \
                strPodcastEpisodeDownloadTotalNotice + '\n') 
                        
            
            if not self.bIncludeNumbersOfRetriesInPodcastStatsEmails: return
            
            #Add "The total number of the podcast-log AWS S3 objects 
            #containing one or more of the podcast-episode download entries 
            #on this date"
            strTotalNumberOfPodcastLogAwsS3ObjectsForThisDate = eval( \
                self.dictLanguagesToTotalDailyPodcastLogCountDescriptors[ \
                self.strPodcastStatsReportLanguage])
                
            self.str_listHtmlEmailBody.append('<p>' + \
                strTotalNumberOfPodcastLogAwsS3ObjectsForThisDate + '</p>')
            self.str_listPlainTextEmailBody.append( \
                strTotalNumberOfPodcastLogAwsS3ObjectsForThisDate)             
            
        else:
            strPodcastEpisodeDownloadTotalNotice = eval( \
                self.dictLanguagesToAllPodcastsNonDailyDownloadCountDescriptors[ \
                self.strPodcastStatsReportLanguage])
                
            self.str_listHtmlEmailBody.append('<p>' + \
                strPodcastEpisodeDownloadTotalNotice + '</p>')
            self.str_listPlainTextEmailBody.append( \
                strPodcastEpisodeDownloadTotalNotice + '\n') 
            
            
    def _CreateEmailPodcastEpisodeDownloadStatsSection(self):
        #======================================================================
        #======================================================================
        #Stage 3 of 4
        #------------
        #Create the main section
        #======================================================================
        #======================================================================   
        
        #######################################################################
        #Create the main section heading with the proper section title
        #in plain-text and HTML.
        #######################################################################
    
        #Add the podcast-episode download stats section heading,
        #with centered podcast-episode AWS S3 bucket folder path or podcast 
        #name in double quotation marks, and " Download Statistics".

        strDoubleQuotedCurrentPodcastName = \
            '"' + self.strCurrentPodcastName + '"'
    
        #Add the HTML header section heading
        self.str_listHtmlEmailBody.append('<br />')
        self.str_listHtmlEmailBody.append('<div class="section_heading">')
        self.str_listHtmlEmailBody.append('<h1 class="section_heading">' + \
            strDoubleQuotedCurrentPodcastName + ' Download Statistics</h1>')
        self.str_listHtmlEmailBody.append('</div>')
        
        #Add the plain-text header section heading
        self.str_listPlainTextEmailBody.append('')
        self.str_listPlainTextEmailBody.append( \
            strDoubleQuotedCurrentPodcastName + ' Download Statistics')
        self.str_listPlainTextEmailBody.append( \
            '==============================================')
        
        
        #######################################################################
        #Add "Total number of podcast episode downloads from this podcast 
        #(during this period):  (number)".
        #######################################################################
        
        #Calculate the total number of podcast episode downloads from this 
        #podcast (during this period).
        iTotalNumberOfPodcastEpisodeDownloadsDuringThisPeriod = 0
        for iDownloadCount in self.dictPodcastDownloadStats.values():
            iTotalNumberOfPodcastEpisodeDownloadsDuringThisPeriod += \
                iDownloadCount
        
        #Add "Total number of podcast episode downloads from this podcast 
        #(during this period):  (number)".
        if self.strDateRangeType == 'daily':
            strPodcastEpisodeDownloadTotalNotice = eval( \
                self.dictLanguagesToPodcastDailyDownloadCountDescriptors[ \
                self.strPodcastStatsReportLanguage])
        else: #weekly and monthly
            strPodcastEpisodeDownloadTotalNotice = eval( \
                self.dictLanguagesToPodcastNonDailyDownloadCountDescriptors[ \
                self.strPodcastStatsReportLanguage])
            
        self.str_listHtmlEmailBody.append('<p>' + \
            strPodcastEpisodeDownloadTotalNotice + '</p>')
        self.str_listPlainTextEmailBody.append( \
            strPodcastEpisodeDownloadTotalNotice + '\n') 
        
        
        #######################################################################
        #Create the podcast-episode download stats text in plain-text and HTML.
        #######################################################################
            
        #Add the download count for each downloaded podcast episode.
        self._BuildHtmlAndPlainTextPodcastDownloadStatsStrings()
        
        
        #######################################################################
        #Create the extra stats in plain-text and HTML (if applicable).
        #######################################################################
        if not self.bIncludeNumbersOfRetriesInPodcastStatsEmails: return
            
        if self.strDateRangeType == 'daily':
            #Add "the total number of the podcast-log AWS S3 objects containing 
            #one or more download entries for this podcast's episodes for this 
            #reporting period".
            #self.dictDatesToPodcastNamesToPodcastLogCounts
            #self.dateCurrentPodcastDownload
            #self.strCurrentPodcastName
            
            iPodcastLogCount = self.dictDatesToPodcastNamesToPodcastLogCounts[ \
                self.dateCurrentPodcastDownload][self.strCurrentPodcastName]
            
            strPodcastLogCountNotice = eval( \
                self.dictLanguagesToPodcastDailyAwsS3LogCountDescriptors[ \
                self.strPodcastStatsReportLanguage])
               
            self.str_listHtmlEmailBody.append('<br />')
            self.str_listHtmlEmailBody.append( \
                '<p>' + strPodcastLogCountNotice + '</p>')
            self.str_listPlainTextEmailBody.append(strPodcastLogCountNotice)         
            
            
            #Add "the total number of access retries on the podcast-log AWS S3 
            #objects containing one or more download entries for this podcast's 
            #episodes for this reporting period".
            #self.dictDatesToPodcastNamesToPodcastLogAccessRetryCounts
            #self.dateCurrentPodcastDownload
            #self.strCurrentPodcastName        
        
            iPodcastLogAccessRetryCount = \
                self.dictDatesToPodcastNamesToPodcastLogAccessRetryCounts[ \
                    self.dateCurrentPodcastDownload][ \
                    self.strCurrentPodcastName]
                
            strPodcastLogAccessRetryCountNotice = eval( \
                self.dictLanguagesToPodcastDailyAwsS3LogAccessRetryCountDescriptors[ \
                self.strPodcastStatsReportLanguage])
                
            self.str_listHtmlEmailBody.append('<p>' + \
                strPodcastLogAccessRetryCountNotice + '</p>')
            self.str_listPlainTextEmailBody.append( \
                strPodcastLogAccessRetryCountNotice)
        else: #weekly or monthly
            strMissingDayCountNotice = '{' + eval( \
                self.dictLanguagesToMissingDaysDescriptors[ \
                self.strPodcastStatsReportLanguage]) + '}'
                
            self.str_listHtmlEmailBody.append('<br />')
            self.str_listHtmlEmailBody.append( \
                '<p>' + strMissingDayCountNotice + '</p>')
            self.str_listPlainTextEmailBody.append(strMissingDayCountNotice)  
            
            
            strNumberOfAccessRetriesCountNotice = '{' + eval( \
                self.dictLanguagesToDailyPodcastStatsAwsS3ObjectAccessRetriesDescriptors[ \
                self.strPodcastStatsReportLanguage]) + '}'
                
            self.str_listHtmlEmailBody.append( \
                '<p>' + strNumberOfAccessRetriesCountNotice + '</p>')
            self.str_listPlainTextEmailBody.append( \
                strNumberOfAccessRetriesCountNotice)  
            
            
            strMissingDailyPodcastStatsAwsS3ObjectsNotice = '{' + eval( \
                self.dictLanguagesToMissingDailyPodcastStatsAwsS3ObjectsDescriptors[ \
                self.strPodcastStatsReportLanguage]) + '}'
                
            self.str_listHtmlEmailBody.append( \
                '<p>' + strMissingDailyPodcastStatsAwsS3ObjectsNotice + '</p>')
            self.str_listPlainTextEmailBody.append( \
                strMissingDailyPodcastStatsAwsS3ObjectsNotice)           
    
    
    def _GenerateEmailBodyForSinglePodcast(self):
        """
        INPUTS
        ------
        self.strDateRangeType
        self.strDateRange
        self.dictPodcastDownloadStats
        self.strCurrentPodcastName
        self.dateCurrentPodcastDownload
        self.dictDatesToPodcastNamesToPodcastLogCounts
        self.dictDatesToPodcastNamesToPodcastLogAccessRetryCounts
        
        self.dateReportPeriodStart
        self.dateReportPeriodEnd
        self.dictPodcastNamesToDailyPodcastDownloadStatsDicts
        (a global data variable for weekly/montly report) "the total number of 
            the podcast-stats AWS S3 objects containing download stats for 
            this weekly/monthly podcast-stats"
        (a global data variable for weekly/montly report) "the total number of 
            access retries on the podcast-stats AWS S3 objects containing 
            podcast stats for this weekly/monthly podcast-stats report"
        (a global data variable for weekly/montly report) (a list of missing 
            daily podcast-log AWS S3 objects.)
        
        OUTPUTS
        -------
        self.strPlainTextEmailBody
        self.strHtmlEmailBody
        """     
        
        
        self._CreateEmailHeaderSection()
        
        self._CreateEmailPodcastEpisodeDownloadStatsSection()  
        
        self.str_listHtmlEmailBody.append('</div></body></html>')
        
        self.strPlainTextEmailBody = '\n'.join(self.str_listPlainTextEmailBody)
        self.strHtmlEmailBody = '\n'.join(self.str_listHtmlEmailBody)
              
        
    def _GenerateEmailBodyForMultiplePodcasts(self):
        """
        INPUTS
        ------
        self.dateReportPeriodStart
        self.dateReportPeriodEnd
        self.strDateRangeType
        self.dictPodcastNamesToDailyPodcastDownloadStatsDicts
        (a global data variable for weekly/montly report) "the total number of 
            the podcast-stats AWS S3 objects containing download stats for 
            this weekly/monthly podcast-stats"
        (a global data variable for weekly/montly report) "the total number of 
            access retries on the podcast-stats AWS S3 objects containing 
            podcast stats for this weekly/monthly podcast-stats report"
        (a global data variable for weekly/montly report) (a list of missing 
            daily podcast-log AWS S3 objects.)
        
        OUTPUTS
        -------
        self.strPlainTextEmailBody
        self.strHtmlEmailBody
        """
        
        self._CreateEmailHeaderSection()
        
        
        if self.strDateRangeType == 'daily':
            str_listPodcastNames = \
                list(self.dictPodcastNamesToDailyPodcastDownloadStatsDicts.keys())
        else:
            str_listPodcastNames = self.str_listPodcastNamesInStatsReports
        
        for self.strCurrentPodcastName in str_listPodcastNames:    
        
            self._AssignPodcastStatsClassMemberDataVariablesForEmailing()

            self._CreateEmailPodcastEpisodeDownloadStatsSection()
        
        
        self.str_listHtmlEmailBody.append('</div></body></html>')
        
        self.strPlainTextEmailBody = '\n'.join(self.str_listPlainTextEmailBody)
        self.strHtmlEmailBody = '\n'.join(self.str_listHtmlEmailBody)
        
        
    def _BuildPodcastDownloadStatsForWeeklyOrMonthlyReport(self):
        """
        FUNCTIONALITY
        -------------
        This function processes the relevant daily podcast-stats AWS S3 
        objects, builds and stores the weekly or monthly podcast-stats data
        in the relevant global data variables, for self.strCurrentPodcastName.
        
        
        INPUTS
        ------
        self.strCurrentPodcastName
        self.dictPodcastNamesToPodcastStatsAwsS3BucketNameAndObjectPrefixLists
        
        self.dateCurrentPodcastDownload
        self.dateReportPeriodStart
        self.dateReportPeriodEnd
        
        
        OUTPUTS
        -------
        self.dictPodcastDownloadStats
        
        (the updated relevant weekly and monthly global data variables.)
        self.iNumberOfMissingDaysFromThisWeeklyOrMonthlyPodcastStatsReport
        self.iTotalNumberOfPodcastStatsAwsS3ObjectAccessRetriesInThisWeeklyOrMonthlyPodcastStatsReport
        self.strCommaSeparatedListOfMissingDailyPodcastStatsAwsS3Objects
        
        self.dictPodcastNamesToDateRangesToMissingDayCounts
        self.dictPodcastNamesToDateRangesToPodcastStatsAwsS3ObjectAccessRetryCounts
        self.dictPodcastNamesToDateRangesToMissingDailyPodcastStatsAwsS3ObjectCommaSeparatedListStrings
        
        self.dictEndingDatesToPodcastNamesToWeeklyPodcastDownloadStatsDicts
        self.dictEndingDatesToPodcastNamesToMonthlyPodcastDownloadStatsDicts      
        """
        
        
        #######################################################################
        #######################################################################
        #Initialize the needed data variables.
        #######################################################################
        #######################################################################
        self.iNumberOfMissingDaysFromThisWeeklyOrMonthlyPodcastStatsReport = 0
        self.iTotalNumberOfPodcastStatsAwsS3ObjectAccessRetriesInThisWeeklyOrMonthlyPodcastStatsReport \
            = 0
        self.strCommaSeparatedListOfMissingDailyPodcastStatsAwsS3Objects = '' 
           
        dateToProcess = self.dateReportPeriodStart
        timedeltaDay = datetime.timedelta(days=1)
        
        str_listPodcastStatsAwsS3BucketNameAndObjectPrefix = \
            self.dictPodcastNamesToPodcastStatsAwsS3BucketNameAndObjectPrefixLists[ \
                self.strCurrentPodcastName]
        self.strCurrentPodcastStatsAwsS3BucketName = \
            str_listPodcastStatsAwsS3BucketNameAndObjectPrefix[0]
        self.strCurrentPodcastStatsAwsS3ObjectPrefix = \
            str_listPodcastStatsAwsS3BucketNameAndObjectPrefix[1]
            
        strPodcastEpisodeAwsS3BucketFolderPath = \
            self.dictPodcastNamesToPodcastEpisodeAwsS3BucketFolderPaths[ \
                self.strCurrentPodcastName]
            
            
        #######################################################################
        #Get self.dictPodcastDownloadStats.
        #######################################################################   
        if self.strDateRangeType == 'weekly':
            dictEndingDatesToPodcastNamesToPodcastDownloadStatsDicts = \
                self.dictEndingDatesToPodcastNamesToWeeklyPodcastDownloadStatsDicts
        else: #'monthly'
            dictEndingDatesToPodcastNamesToPodcastDownloadStatsDicts = \
                self.dictEndingDatesToPodcastNamesToMonthlyPodcastDownloadStatsDicts
        
        if self.dateCurrentPodcastDownload in \
            dictEndingDatesToPodcastNamesToPodcastDownloadStatsDicts:
            dictPodcastNamesToNonDailyPodcastDownloadStatsDicts = \
                dictEndingDatesToPodcastNamesToPodcastDownloadStatsDicts[ \
                self.dateCurrentPodcastDownload]
        else:
            dictPodcastNamesToNonDailyPodcastDownloadStatsDicts = {}
            dictEndingDatesToPodcastNamesToPodcastDownloadStatsDicts[ \
                self.dateCurrentPodcastDownload] = \
                dictPodcastNamesToNonDailyPodcastDownloadStatsDicts
                
        if self.strCurrentPodcastName in \
            dictPodcastNamesToNonDailyPodcastDownloadStatsDicts:
            self.dictPodcastDownloadStats = \
                dictPodcastNamesToNonDailyPodcastDownloadStatsDicts[ \
                    self.strCurrentPodcastName]
        else:
            self.dictPodcastDownloadStats = {}
            dictPodcastNamesToNonDailyPodcastDownloadStatsDicts[ \
                self.strCurrentPodcastName] = self.dictPodcastDownloadStats
                                                                                                                      
            
        #######################################################################
        #######################################################################
        #Iterate over each date to get the podcast-episode download stats of 
        #each date.
        #######################################################################
        #######################################################################
        while dateToProcess <= self.dateReportPeriodEnd:
        
            #Use the code in self._GetPodcastStatsAwsS3BucketNameAndObjectKey()
            #here.
            strDateRange = str(dateToProcess.year) + '-' + \
                str(dateToProcess.month).zfill(2) + '-' + \
                str(dateToProcess.day).zfill(2)
            if self.strCurrentPodcastStatsAwsS3ObjectPrefix == '':
                self.strCurrentPodcastStatsAwsS3ObjectKey = \
                    strPodcastEpisodeAwsS3BucketFolderPath.replace('/', '_') + \
                    ' ' + strDateRange
            else:
                self.strCurrentPodcastStatsAwsS3ObjectKey = \
                    self.strCurrentPodcastStatsAwsS3ObjectPrefix + '/' + \
                    strPodcastEpisodeAwsS3BucketFolderPath.replace('/', '_') + \
                    ' ' + strDateRange            
            
            #Use self._CheckAwsS3ObjectExistence().
            if not self._CheckAwsS3ObjectExistence():
                self.iNumberOfMissingDaysFromThisWeeklyOrMonthlyPodcastStatsReport \
                    += 1
                #add to 
                #self.strCommaSeparatedListOfMissingDailyPodcastStatsAwsS3Objects
                if self.strCommaSeparatedListOfMissingDailyPodcastStatsAwsS3Objects \
                    != '':
                    self.strCommaSeparatedListOfMissingDailyPodcastStatsAwsS3Objects \
                        += ', '
                self.strCommaSeparatedListOfMissingDailyPodcastStatsAwsS3Objects \
                    += self.strCurrentPodcastStatsAwsS3ObjectKey

                dateToProcess += timedeltaDay
                continue
            
            #Get s3_objectToRead.
            s3_objectToRead = self.s3_resource.Object( \
                self.strCurrentPodcastStatsAwsS3BucketName, \
                self.strCurrentPodcastStatsAwsS3ObjectKey)        
            
            #Use self._GetAwsS3ObjectContentInUtf8().
            strAwsS3DailyPodcastStats, \
            iPodcastStatsAwsS3ObjectReadRetryAttempts = \
                self._GetAwsS3ObjectContentInUtf8(s3_objectToRead)        
            
            self.iTotalNumberOfPodcastStatsAwsS3ObjectAccessRetriesInThisWeeklyOrMonthlyPodcastStatsReport \
                += iPodcastStatsAwsS3ObjectReadRetryAttempts
            
            #Update the output data variables.
            for strAwsS3DailyPodcastStat in \
                strAwsS3DailyPodcastStats.split('\n'):
                if strAwsS3DailyPodcastStat == '':
                    break
                
                regexp_match_objPodcastStatsAwsS3ObjectLine = \
                    self.regexp_objPodcastStatsAwsS3ObjectLineParser.search( \
                        strAwsS3DailyPodcastStat)
                    
                if regexp_match_objPodcastStatsAwsS3ObjectLine == None:
                    raise Exception("Critical error.  A corrupt daily \
podcast-stats AWS S3 object:  A line is in an incorrect format.  \n" \
                        + self.strCurrentPodcastStatsAwsS3BucketName + '/' \
                        + self.strCurrentPodcastStatsAwsS3ObjectKey)
                
                strPodcastEpisodeName = \
                    regexp_match_objPodcastStatsAwsS3ObjectLine.group(1)
                strPodcastEpisodeDownloadCount = \
                    regexp_match_objPodcastStatsAwsS3ObjectLine.group(2)
                
                try:
                    iPodcastEpisodeDownloadCount = \
                        int(strPodcastEpisodeDownloadCount)
                except:
                    raise Exception("Critical error.  A corrupt podcast-stats \
AWS S3 object:  A download count is not an integer.  \n" \
                        + self.strCurrentPodcastStatsAwsS3BucketName + '/' \
                        + self.strCurrentPodcastStatsAwsS3ObjectKey)             
            
                #Update
                #self.dictEndingDatesToPodcastNamesToWeeklyPodcastDownloadStatsDicts
                #or
                #self.dictEndingDatesToPodcastNamesToMonthlyPodcastDownloadStatsDicts                                                                         
                if strPodcastEpisodeName in self.dictPodcastDownloadStats:
                    self.dictPodcastDownloadStats[strPodcastEpisodeName] += \
                        iPodcastEpisodeDownloadCount
                else:
                    self.dictPodcastDownloadStats[strPodcastEpisodeName] = \
                        iPodcastEpisodeDownloadCount
                
            
            dateToProcess += timedeltaDay
               
            
        #######################################################################
        #######################################################################
        #Update the output data variables.
        #######################################################################
        #######################################################################
        tupleDateRange = (self.dateReportPeriodStart, self.dateReportPeriodEnd)
        
        if self.strCurrentPodcastName in \
            self.dictPodcastNamesToDateRangesToMissingDayCounts:
            dictDateRangesToMissingDayCounts = \
                self.dictPodcastNamesToDateRangesToMissingDayCounts[ \
                    self.strCurrentPodcastName]
        else:
            dictDateRangesToMissingDayCounts = {}
            self.dictPodcastNamesToDateRangesToMissingDayCounts[ \
                self.strCurrentPodcastName] = dictDateRangesToMissingDayCounts          
        dictDateRangesToMissingDayCounts[tupleDateRange] = \
            self.iNumberOfMissingDaysFromThisWeeklyOrMonthlyPodcastStatsReport
            
        if self.strCurrentPodcastName in \
            self.dictPodcastNamesToDateRangesToPodcastStatsAwsS3ObjectAccessRetryCounts:
            dictDateRangesToPodcastStatsAwsS3ObjectAccessRetryCounts = \
                self.dictPodcastNamesToDateRangesToPodcastStatsAwsS3ObjectAccessRetryCounts[ \
                    self.strCurrentPodcastName]
        else:
            dictDateRangesToPodcastStatsAwsS3ObjectAccessRetryCounts = {}
            self.dictPodcastNamesToDateRangesToPodcastStatsAwsS3ObjectAccessRetryCounts[ \
                self.strCurrentPodcastName] = \
                dictDateRangesToPodcastStatsAwsS3ObjectAccessRetryCounts
        dictDateRangesToPodcastStatsAwsS3ObjectAccessRetryCounts[tupleDateRange] = \
            self.iTotalNumberOfPodcastStatsAwsS3ObjectAccessRetriesInThisWeeklyOrMonthlyPodcastStatsReport
            
        if self.strCurrentPodcastName in \
            self.dictPodcastNamesToDateRangesToMissingDailyPodcastStatsAwsS3ObjectCommaSeparatedListStrings:
            dictDateRangesToMissingDailyPodcastStatsAwsS3ObjectCommaSeparatedListStrings \
                = self.dictPodcastNamesToDateRangesToMissingDailyPodcastStatsAwsS3ObjectCommaSeparatedListStrings[ \
                    self.strCurrentPodcastName]
        else:
            dictDateRangesToMissingDailyPodcastStatsAwsS3ObjectCommaSeparatedListStrings \
                = {}
            self.dictPodcastNamesToDateRangesToMissingDailyPodcastStatsAwsS3ObjectCommaSeparatedListStrings[ \
                self.strCurrentPodcastName] = \
                dictDateRangesToMissingDailyPodcastStatsAwsS3ObjectCommaSeparatedListStrings
        dictDateRangesToMissingDailyPodcastStatsAwsS3ObjectCommaSeparatedListStrings[ \
            tupleDateRange] = \
            self.strCommaSeparatedListOfMissingDailyPodcastStatsAwsS3Objects
        
                                                                                     
    def _BuildHtmlAndPlainTextPodcastDownloadStatsStrings(self):
        """
        INPUTS
        ------
        self.strCurrentPodcastName
        self.dictPodcastDownloadStats
            (if daily, this data value already exists;
            otherwise it is generated in this function
            by calling 
            self._BuildPodcastDownloadStatsForWeeklyOrMonthlyReport().)
        self.strFirstColumnDataTypeInEmail ('count' or 'name')
        
        
        OUTPUTS
        -------
        Podcast-episode download stats appended to self.str_listHtmlEmailBody,
        for a single podcast indicated by self.strCurrentPodcastName.
        
        Podcast-episode download stats appended to 
        self.str_listPlainTextEmailBody, for a single podcast indicated by 
        self.strCurrentPodcastName.
        
        
        (If weekly or monthly email report, the following outputs updated as 
        well.)
        self.iNumberOfMissingDaysFromThisWeeklyOrMonthlyPodcastStatsReport
        self.iTotalNumberOfPodcastStatsAwsS3ObjectAccessRetriesInThisWeeklyOrMonthlyPodcastStatsReport
        self.strCommaSeparatedListOfMissingDailyPodcastStatsAwsS3Objects
        
        self.dictPodcastNamesToDateRangesToMissingDayCounts
            NOTE instead of a weekly/montly-report global data variable
            for "the total number of the podcast-stats AWS S3 objects 
            containing download stats for this weekly/monthly podcast-stats", 
            the above self.dictPodcastNamesToDateRangesToMissingDayCounts is 
            used for reporting the number of missing daily podcast-stats AWS 
            S3 objects in each weekly or monthly report.
        self.dictPodcastNamesToDateRangesToPodcastStatsAwsS3ObjectAccessRetryCounts
            NOTE the above weekly/montly-report global data variable, is for
            "the total number of access retries on the daily podcast-stats 
            AWS S3 objects containing one or more podcast-episode download 
            stats for this weekly/monthly podcast-stats report"
        self.dictPodcastNamesToDateRangesToMissingDailyPodcastStatsAwsS3ObjectCommaSeparatedListStrings
        
        self.dictEndingDatesToPodcastNamesToWeeklyPodcastDownloadStatsDicts
        self.dictEndingDatesToPodcastNamesToMonthlyPodcastDownloadStatsDicts  
        """
        
        
        #Open the <table> element in self.str_listHtmlEmailBody.
        self.str_listHtmlEmailBody.append( \
            '<table class="podcast_download_stats">')
        
        #Get the maximum number of digits in podcast-episode download counts.
        iMaximumNumberOfDigitsInPodcastEpisodeDownloadCount = 0
        for iDownloadCount in self.dictPodcastDownloadStats.values():
            iNumberOfDigits = int(math.log10(iDownloadCount))+1
            
            if iMaximumNumberOfDigitsInPodcastEpisodeDownloadCount < \
                iNumberOfDigits:
                iMaximumNumberOfDigitsInPodcastEpisodeDownloadCount = \
                    iNumberOfDigits
        
        
        #Add the podcast-episode download count entries.
        tuple_listSortedPodcastDownloadStats = \
            sorted(self.dictPodcastDownloadStats.items(), reverse=True)        
        
        for strPodcastEpisodeFileName, iDownloadCount in \
            tuple_listSortedPodcastDownloadStats:
            
            if self.strFirstColumnDataTypeInEmail == 'count':
                self.str_listHtmlEmailBody.append('<tr><td>' + \
                    str(iDownloadCount) + \
                    '</td><td class="podcast_episode_name">' + \
                    strPodcastEpisodeFileName + '</td></tr>')
                
                iNumberOfDownloadCountDigits = \
                    int(math.log10(iDownloadCount)) + 1
                iNumberOfPaddingSpaceCharacters = \
                    iMaximumNumberOfDigitsInPodcastEpisodeDownloadCount - \
                    iNumberOfDownloadCountDigits
                self.str_listPlainTextEmailBody.append( \
                    ' ' * iNumberOfPaddingSpaceCharacters + \
                    str(iDownloadCount) + ' ' + strPodcastEpisodeFileName)
            else: #'name'
                self.str_listHtmlEmailBody.append( \
                    '<tr><td>' + strPodcastEpisodeFileName + \
                    '</td><td class="podcast_episode_name">' + \
                    str(iDownloadCount) + '</td></tr>')
                
                self.str_listPlainTextEmailBody.append( \
                    strPodcastEpisodeFileName + ' ' + str(iDownloadCount))
                
                
        #Close the <table> element in self.str_listHtmlEmailBody.
        self.str_listHtmlEmailBody.append('</table>')
        
        
    def _SendEmail(self):
        """
        INPUTS
        ------
        self.strEmailTitle
        self.strPlainTextEmailBody
        self.strHtmlEmailBody
        
        
        OUTPUTS
        -------
        The sent email
        """    
        
        
        dictSesSendEmailResponse = self.ses_client.send_email(
          Source          = self.strPodcastStatsSenderName + ' <' + \
              self.strPodcastStatsSenderEmailAddress + '>',
          Destination     = {
            'ToAddresses' : [
              self.strPodcastStatsRecipientEmailAddress,
            ]
          },
        
          Message = {
            'Subject'    : {
              'Data'     : self.strEmailTitle,
              'Charset'  : 'UTF-8'
            },
            'Body'       : {
              'Text'     : {
                'Data'   : self.strPlainTextEmailBody,
                'Charset': 'UTF-8'
              },
              'Html'     : {
                'Data'   : self.strHtmlEmailBody,
                'Charset': 'UTF-8'
              }
            }
          },
        
          ReplyToAddresses = [
            self.strPodcastStatsSenderEmailAddress,
          ],
                  
          ReturnPath = self.strPodcastStatsSenderEmailAddress,   
        )
    
    
        #Save the email-send retry count in self._SendEmail()
        #and use that in self._SavePodcastStats() to save the email-send retry 
        #stat.
        if self.bSeparatePodcastStatsEmails:
            self.dictPodcastNamesToPodcastStatsEmailSendingRetryCounts[ \
                self.strCurrentPodcastName] = \
                dictSesSendEmailResponse['ResponseMetadata']['RetryAttempts']
        else:
            for strPodcastName in \
                self.str_listMissingPodcastStatsAwsS3ObjectPodcastNames:
                self.dictPodcastNamesToPodcastStatsEmailSendingRetryCounts[ \
                    strPodcastName] = dictSesSendEmailResponse[ \
                    'ResponseMetadata']['RetryAttempts']                    
            
    
    def _SavePodcastStats(self):
        """
        FUNCTIONALITY
        -------------
        This function is called in self._EmailAndSavePodcastStats(), as many  
        times as needed, to generate and save the content of the unsaved 
        daily, weekly, or monthly podcast-stats AWS S3 object, for every 
        podcast, for a certain date (if daily) or date range (if weekly or 
        monthly).
        
        (That is, this single function performs the task of generating and 
        saving the content of every podcast-stats AWS S3 object, which is 
        quite a bit of important computing work in AWS-hosted online content 
        marketing.)
        
        
        A single podcast-stats AWS S3 object contains the podcast-episode  
        download stats, and some additional stats at the bottom, for a single 
        podcast, for a date if a daily report, or a date range, if a weekly or 
        monthly report.
        
        
        INPUTS
        ------
        self.strDateRangeType
        
        self.str_listMissingPodcastStatsAwsS3ObjectPodcastNames
        self.str_list_listMissingPodcastStatsAwsS3ObjectBucketNameAndObjectKeyLists
            
        self.dictPodcastNamesToDailyPodcastDownloadStatsDicts
        
        self.dateCurrentPodcastDownload
    
        self.dictDatesToTotalNumbersOfPodcastLogAwsS3Objects
        self.dictDatesToPodcastNamesToPodcastLogCounts
        self.dictDatesToPodcastNamesToPodcastLogAccessRetryCounts    
        
        self.dictEndingDatesToPodcastNamesToWeeklyPodcastDownloadStatsDicts
        self.dictEndingDatesToPodcastNamesToMonthlyPodcastDownloadStatsDicts
        
        self.dateReportPeriodStart
        self.dateReportPeriodEnd    
        
        self.dictPodcastNamesToDateRangesToMissingDayCounts
        self.dictPodcastNamesToDateRangesToPodcastStatsAwsS3ObjectAccessRetryCounts
        self.dictPodcastNamesToDateRangesToMissingDailyPodcastStatsAwsS3ObjectCommaSeparatedListStrings
    
        self.dictPodcastNamesToPodcastStatsEmailSendingRetryCounts    
        
        
        OUTPUTS
        -------
        Generated and saved podcast-stats AWS S3 objects for all the podcasts
        that are not saved yet, for self.dateCurrentPodcastDownload and
        self.strDateRangeType.
        
        
        IMPLEMENTATION TECHNIQUES
        -------------------------
        Include the number of email retries in the podcast-stats AWS S3 
        objects.
        
        For weekly and monthly podcast-stats AWS S3 objects,
        use self.str_listMissingPodcastStatsAwsS3ObjectPodcastNames and
        self.str_list_listMissingPodcastStatsAwsS3ObjectBucketNameAndObjectKeyLists,
        to save only the missing weekly or monthly podcast-stats AWS S3 
        objects.
        The above two data variables are assigned to in
        self._CheckAllPodcastStatsAwsS3ObjectExistences(), which is called in 
        self._EmailAndSavePodcastStats().
        
        Since the above two global data variables are used, no need to use
        self._GetPodcastStatsAwsS3BucketNameAndObjectKey().
        
        Use self._AddAwsS3Object() to save the podcast-stats AWS S3 objects.
    
    
        The podcast-stats AWS S3 object content must be generated by this 
        function, and stored in self.str_listPodcastStatsAwsS3ObjectContent 
        and self.strPodcastStatsAwsS3ObjectContent for saving by 
        self._AddAwsS3Object().
        The email content cannot be re-used, since the content formats are 
        different.
    
        For memory usage optimization, this function deletes the in-memory 
        data that's no longer needed.  (This feature is not implemented yet.)
        """      
           
        tupleDateRange = (self.dateReportPeriodStart, self.dateReportPeriodEnd)        
        
        if self.strDateRangeType == 'daily':
            for iZeroBasedMissingPodcastStatsAwsS3ObjectIndex, \
                self.strCurrentPodcastName in \
                enumerate( \
                self.str_listMissingPodcastStatsAwsS3ObjectPodcastNames):
                    
                self.strCurrentPodcastStatsAwsS3BucketName, \
                    self.strCurrentPodcastStatsAwsS3ObjectKey = \
                    self.str_list_listMissingPodcastStatsAwsS3ObjectBucketNameAndObjectKeyLists[ \
                    iZeroBasedMissingPodcastStatsAwsS3ObjectIndex]
                self.dictPodcastDownloadStats = \
                    self.dictPodcastNamesToDailyPodcastDownloadStatsDicts[ \
                    self.strCurrentPodcastName]
                
                self._BuildPodcastStatsAwsS3ObjectContent()
                
                self.str_listPodcastStatsAwsS3ObjectContent.append('')
                
                iTotalNumberOfPodcastEpisodeDownloadsDuringThisPeriod = \
                    self.dictDateRangesToTotalDownloadCounts[tupleDateRange]                 
                strPodcastEpisodeDownloadTotalNotice = eval( \
                    self.dictLanguagesToAllPodcastsDailyDownloadCountDescriptors[ \
                    self.strPodcastStatsReportLanguage]) 
                self.str_listPodcastStatsAwsS3ObjectContent.append( \
                    strPodcastEpisodeDownloadTotalNotice)
                
                strDoubleQuotedCurrentPodcastName = \
                    '"' + self.strCurrentPodcastName + '"' 
                iTotalNumberOfPodcastEpisodeDownloadsDuringThisPeriod = 0
                for iDownloadCount in self.dictPodcastDownloadStats.values():
                    iTotalNumberOfPodcastEpisodeDownloadsDuringThisPeriod += \
                        iDownloadCount  
                strPodcastEpisodeDownloadTotalNotice = eval( \
                    self.dictLanguagesToPodcastDailyDownloadCountDescriptors[ \
                    self.strPodcastStatsReportLanguage])
                self.str_listPodcastStatsAwsS3ObjectContent.append( \
                    strPodcastEpisodeDownloadTotalNotice)
                
                self.str_listPodcastStatsAwsS3ObjectContent.append('')
                
                        
                #In each daily podcast-episode download stats AWS S3 object,
                #include the following four pieces of extra data.
                #(the numbers of relevant-download podcast-log AWS S3 objects 
                #are always included in podcast-stats S3 objects.)
                #-the total number of the podcast log S3 objects accessed on 
                #  that date
                #-the total number of the podcast log S3 objects accessed on 
                #  that date for the podcast
                #-the total number of the podcast log S3 object access retries
                #  for the podcast
                #-podcast-stats email sending retry count
                strTotalNumberOfPodcastLogAwsS3ObjectsForThisDate = eval( \
                    self.dictLanguagesToTotalDailyPodcastLogCountDescriptors2[ \
                    self.strPodcastStatsReportLanguage])
                self.str_listPodcastStatsAwsS3ObjectContent.append( \
                    strTotalNumberOfPodcastLogAwsS3ObjectsForThisDate)
                
                iPodcastLogCount = self.dictDatesToPodcastNamesToPodcastLogCounts[ \
                    self.dateCurrentPodcastDownload][self.strCurrentPodcastName]
                strPodcastLogCountNotice = eval( \
                    self.dictLanguagesToPodcastDailyAwsS3LogCountDescriptors2[ \
                    self.strPodcastStatsReportLanguage])
                self.str_listPodcastStatsAwsS3ObjectContent.append( \
                    strPodcastLogCountNotice)
                
                iPodcastLogAccessRetryCount = \
                    self.dictDatesToPodcastNamesToPodcastLogAccessRetryCounts[ \
                        self.dateCurrentPodcastDownload][ \
                        self.strCurrentPodcastName]
                strPodcastLogAccessRetryCountNotice = eval( \
                    self.dictLanguagesToPodcastDailyAwsS3LogAccessRetryCountDescriptors2[ \
                    self.strPodcastStatsReportLanguage])
                self.str_listPodcastStatsAwsS3ObjectContent.append( \
                    strPodcastLogAccessRetryCountNotice)
                
                self.str_listPodcastStatsAwsS3ObjectContent.append('')
                
                self.iPodcastStatsEmailSendingRetryCount = \
                    self.dictPodcastNamesToPodcastStatsEmailSendingRetryCounts[ \
                    self.strCurrentPodcastName]
                strPodcastStatsEmailSendingRetryCountNotice = eval( \
                    self.dictLanguagesToEmailSendingRetriesDescriptors[ \
                    self.strPodcastStatsReportLanguage])
                self.str_listPodcastStatsAwsS3ObjectContent.append( \
                    strPodcastStatsEmailSendingRetryCountNotice)
                
                
                self.strPodcastStatsAwsS3ObjectContent = '\n'.join( \
                    self.str_listPodcastStatsAwsS3ObjectContent)
                self._AddAwsS3Object()
        else:
            if self.strDateRangeType == 'weekly':
                dictPodcastNamesToPodcastDownloadStatsDicts = \
                    self.dictEndingDatesToPodcastNamesToWeeklyPodcastDownloadStatsDicts[ \
                        self.dateCurrentPodcastDownload]  
            else: #'monthly'
                dictPodcastNamesToPodcastDownloadStatsDicts = \
                    self.dictEndingDatesToPodcastNamesToMonthlyPodcastDownloadStatsDicts[ \
                        self.dateCurrentPodcastDownload]
                    
                    
            for iZeroBasedMissingPodcastStatsAwsS3ObjectIndex, \
                self.strCurrentPodcastName in \
                enumerate( \
                self.str_listMissingPodcastStatsAwsS3ObjectPodcastNames):
                    
                self.strCurrentPodcastStatsAwsS3BucketName, \
                    self.strCurrentPodcastStatsAwsS3ObjectKey = \
                    self.str_list_listMissingPodcastStatsAwsS3ObjectBucketNameAndObjectKeyLists[ \
                    iZeroBasedMissingPodcastStatsAwsS3ObjectIndex]
                self.dictPodcastDownloadStats = \
                    dictPodcastNamesToPodcastDownloadStatsDicts[ \
                    self.strCurrentPodcastName]        
                
                self._BuildPodcastStatsAwsS3ObjectContent()
                
                self.str_listPodcastStatsAwsS3ObjectContent.append('')
                
                iTotalNumberOfPodcastEpisodeDownloadsDuringThisPeriod = \
                    self.dictDateRangesToTotalDownloadCounts[tupleDateRange]                 
                strPodcastEpisodeDownloadTotalNotice = eval( \
                    self.dictLanguagesToAllPodcastsNonDailyDownloadCountDescriptors[ \
                    self.strPodcastStatsReportLanguage]) 
                self.str_listPodcastStatsAwsS3ObjectContent.append( \
                    strPodcastEpisodeDownloadTotalNotice)
                
                strDoubleQuotedCurrentPodcastName = \
                    '"' + self.strCurrentPodcastName + '"' 
                iTotalNumberOfPodcastEpisodeDownloadsDuringThisPeriod = 0
                for iDownloadCount in self.dictPodcastDownloadStats.values():
                    iTotalNumberOfPodcastEpisodeDownloadsDuringThisPeriod += \
                        iDownloadCount  
                strPodcastEpisodeDownloadTotalNotice = eval( \
                    self.dictLanguagesToPodcastNonDailyDownloadCountDescriptors[ \
                    self.strPodcastStatsReportLanguage]) 
                self.str_listPodcastStatsAwsS3ObjectContent.append( \
                    strPodcastEpisodeDownloadTotalNotice)                        
                
                self.str_listPodcastStatsAwsS3ObjectContent.append('')                
            
            
                #In each weekly and monthly podcast-episode download stats AWS  
                #S3 object, include the following four pieces of extra data.
                #-the total number of missing days from this weekly or monthly 
                #  podcast stats report
                #-total number of daily podcast stats aws s3 object access   
                #  retries in this weekly or monthly podcast stats report
                #-comma-separated list of missing daily podcast-log aws s3 
                #  objects
                #-podcast-stats email sending retry count
                self.iNumberOfMissingDaysFromThisWeeklyOrMonthlyPodcastStatsReport = \
                    self.dictPodcastNamesToDateRangesToMissingDayCounts[ \
                        self.strCurrentPodcastName][tupleDateRange]
                strMissingDayCountNotice = eval( \
                    self.dictLanguagesToMissingDaysDescriptors[ \
                    self.strPodcastStatsReportLanguage])               
                self.str_listPodcastStatsAwsS3ObjectContent.append( \
                    strMissingDayCountNotice)
    
                self.iTotalNumberOfPodcastStatsAwsS3ObjectAccessRetriesInThisWeeklyOrMonthlyPodcastStatsReport \
                    = self.dictPodcastNamesToDateRangesToPodcastStatsAwsS3ObjectAccessRetryCounts[ \
                    self.strCurrentPodcastName][tupleDateRange]
                strNumberOfAccessRetriesCountNotice = eval( \
                    self.dictLanguagesToDailyPodcastStatsAwsS3ObjectAccessRetriesDescriptors[ \
                    self.strPodcastStatsReportLanguage])                
                self.str_listPodcastStatsAwsS3ObjectContent.append( \
                    strNumberOfAccessRetriesCountNotice)
    
                self.strCommaSeparatedListOfMissingDailyPodcastStatsAwsS3Objects = \
                    self.dictPodcastNamesToDateRangesToMissingDailyPodcastStatsAwsS3ObjectCommaSeparatedListStrings[ \
                    self.strCurrentPodcastName][tupleDateRange]
                strMissingDailyPodcastLogAwsS3ObjectsNotice = eval( \
                    self.dictLanguagesToMissingDailyPodcastStatsAwsS3ObjectsDescriptors[ \
                    self.strPodcastStatsReportLanguage])
                self.str_listPodcastStatsAwsS3ObjectContent.append( \
                    strMissingDailyPodcastLogAwsS3ObjectsNotice)
                
                self.str_listPodcastStatsAwsS3ObjectContent.append('')
                
                if self.strCurrentPodcastName in \
                    self.dictPodcastNamesToPodcastStatsEmailSendingRetryCounts:
                    self.iPodcastStatsEmailSendingRetryCount = \
                        self.dictPodcastNamesToPodcastStatsEmailSendingRetryCounts[ \
                        self.strCurrentPodcastName]
                else:
                    self.iPodcastStatsEmailSendingRetryCount = 0
                strPodcastStatsEmailSendingRetryCountNotice = eval( \
                    self.dictLanguagesToEmailSendingRetriesDescriptors[ \
                    self.strPodcastStatsReportLanguage])
                self.str_listPodcastStatsAwsS3ObjectContent.append( \
                    strPodcastStatsEmailSendingRetryCountNotice)
                
                
                self.strPodcastStatsAwsS3ObjectContent = '\n'.join( \
                    self.str_listPodcastStatsAwsS3ObjectContent)
                self._AddAwsS3Object()              
     
            
    def _BuildPodcastStatsAwsS3ObjectContent(self):
        """
        INPUTS
        ------
        self.dictPodcastDownloadStats  
        
        
        OUTPUTS
        -------
        Initialized and updated self.str_listPodcastStatsAwsS3ObjectContent.
        """          
        
        
        self.str_listPodcastStatsAwsS3ObjectContent = []
        
        tuple_listSortedPodcastDownloadStats = \
            sorted(self.dictPodcastDownloadStats.items(), reverse=True)          
        
        for strPodcastEpisodeFileName, iDownloadCount in \
            tuple_listSortedPodcastDownloadStats:
            self.str_listPodcastStatsAwsS3ObjectContent.append( \
                strPodcastEpisodeFileName + '\t' + str(iDownloadCount))
        
        
    def _AddAwsS3Object(self):
        """
        INPUTS
        ------
        self.strCurrentPodcastStatsAwsS3BucketName
        self.strCurrentPodcastStatsAwsS3ObjectKey
        self.strPodcastStatsAwsS3ObjectContent    
        
        
        OUTPUTS
        -------
        The saved podcast-stats AWS S3 object.
        """      
    
                
        bytesAwsS3ObjectBody = bytes(self.strPodcastStatsAwsS3ObjectContent, \
                                     'utf-8')
            
        try:
            s3_objectToAdd = self.s3_resource.Object( \
                self.strCurrentPodcastStatsAwsS3BucketName,
                self.strCurrentPodcastStatsAwsS3ObjectKey)  
            
            dictS3ObjectPutResponse = \
                s3_objectToAdd.put(Body=bytesAwsS3ObjectBody)
            s3_objectToAdd.wait_until_exists()
        except botocore.exceptions.ClientError as exc:
            raise Exception( \
                "Couldn't put object '{0}' to bucket '{1}'.  ".format( \
                self.strCurrentPodcastStatsAwsS3ObjectKey,
                self.strCurrentPodcastStatsAwsS3BucketName) + '\n' + str(exc))
          
    
    def _ReportDailyPodcastStats(self):
        self.dateReportPeriodStart = self.dateCurrentPodcastDownload
        self.dateReportPeriodEnd = self.dateCurrentPodcastDownload
        self.strDateRange = str(self.dateReportPeriodStart.year) + '-' + \
            str(self.dateReportPeriodStart.month).zfill(2) + '-' + \
            str(self.dateReportPeriodStart.day).zfill(2)  
        self.strDateRangeType = 'daily'     
        if not self._CheckAllPodcastStatsAwsS3ObjectExistences():
            self.strEmailTitleHead = self.strDateRange + " daily "
            
            #Email the daily podcast stats.
            self._EmailPodcastStats()
            
        #Save the daily podcast stats.
        self._SavePodcastStats()
                
    
    def _ReportWeeklyPodcastStats(self):
        if self.dateCurrentPodcastDownload.weekday() != 6: #Sunday
            return
        
    
        self.dateReportPeriodStart = self.dateCurrentPodcastDownload \
            - datetime.timedelta(days=6)
        self.dateReportPeriodEnd = self.dateCurrentPodcastDownload
        self.strDateRange = str(self.dateReportPeriodStart.year) + '-' + \
            str(self.dateReportPeriodStart.month).zfill(2) + '-' + \
            str(self.dateReportPeriodStart.day).zfill(2) + " - " + \
            str(self.dateReportPeriodEnd.year) + '-' + \
            str(self.dateReportPeriodEnd.month).zfill(2) + '-' + \
            str(self.dateReportPeriodEnd.day).zfill(2)
        self.strDateRangeType = 'weekly'

        #Call self._BuildPodcastDownloadStatsForWeeklyOrMonthlyReport() for
        #every podcast, to compute the podcast-download stats for the weekly 
        #or monthly report (that will be used in emailing and saving).        
        for self.strCurrentPodcastName in \
            self.str_listPodcastNamesInStatsReports:                
            self._BuildPodcastDownloadStatsForWeeklyOrMonthlyReport()  

        if not self._CheckAllPodcastStatsAwsS3ObjectExistences():
            self.strEmailTitleHead = self.strDateRange + " weekly "
                        
            #Email the weekly podcast stats.
            self._EmailPodcastStats()
            
        #Save the weekly podcast stats.
        self._SavePodcastStats()     
    
    
    def _ReportMonthlyPodcastStats(self):
        iZeroBasedMonthFirstDayWeekday, iNumberOfDaysInMonth = \
            calendar.monthrange(self.dateCurrentPodcastDownload.year,
                self.dateCurrentPodcastDownload.month)
        if self.dateCurrentPodcastDownload.day != iNumberOfDaysInMonth:
            #not end of the month
            return
        
            
        self.dateReportPeriodStart = datetime.date( \
            self.dateCurrentPodcastDownload.year, \
            self.dateCurrentPodcastDownload.month, 1)
        self.dateReportPeriodEnd = self.dateCurrentPodcastDownload
        self.strDateRange = str(self.dateReportPeriodStart.year) + '-' + \
            str(self.dateReportPeriodStart.month).zfill(2) + '-' + \
            str(self.dateReportPeriodStart.day).zfill(2) + " - " + \
            str(self.dateReportPeriodEnd.year) + '-' + \
            str(self.dateReportPeriodEnd.month).zfill(2) + '-' + \
            str(self.dateReportPeriodEnd.day).zfill(2)  
        self.strDateRangeType = 'monthly'           

        #Call self._BuildPodcastDownloadStatsForWeeklyOrMonthlyReport() for
        #every podcast, to compute the podcast-download stats for the weekly 
        #or monthly report (that will be used in emailing and saving).        
        for self.strCurrentPodcastName in \
            self.str_listPodcastNamesInStatsReports:                
            self._BuildPodcastDownloadStatsForWeeklyOrMonthlyReport()  

        if not self._CheckAllPodcastStatsAwsS3ObjectExistences():  
            self.strEmailTitleHead = self.strDateRange + " monthly "
                        
            #Email the monthly podcast stats.
            self._EmailPodcastStats()
            
        #Save the monthly podcast stats.
        self._SavePodcastStats()    
    
    
    def _DeletePodcastLogs(self):
        """
        INPUTS
        ------
        self.dictPodcastLogAwsS3BucketNamesToDeletionPodcastLogAwsS3ObjectKeyLists
        
        
        OUTPUTS
        -------
        All the podcast-log AWS S3 objects in the delete list deleted.
        
        
        IMPLEMENTATION METHOD
        ---------------------
        The AWS S3 objects are deleted in batch.
        
        
        The following are the official references on the AWS S3 objects batch
        deletion.
    
        https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/s3.html#S3.Object.delete
        
        The AWS SDK examples available at
        https://github.com/awsdocs/aws-doc-sdk-examples.
        Download the example package, extract it, and then open the file at
        aws-doc-sdk-examples-master\python\example_code\s3\s3_basics\object_wrapper.py.
        The delete_objects() function in the above file contains the relevant
        example code.
        """    
    
                
        for strPodcastLogAwsS3BucketName, str_listDeletionPodcastLogAwsS3ObjectKeys \
            in self.dictPodcastLogAwsS3BucketNamesToDeletionPodcastLogAwsS3ObjectKeyLists.items():
                
            if len(str_listDeletionPodcastLogAwsS3ObjectKeys) == 0:
                continue

            s3_bucket = self.s3_resource.Bucket(strPodcastLogAwsS3BucketName)
        
            #Delete the maximum number of AWS S3 objects at a time, which is 
            #1000.
            iZeroBasedLastListSegmentIndex = \
                    int(len(str_listDeletionPodcastLogAwsS3ObjectKeys) / 1000)

            for iZeroBasedListSegmentIndex in range(0, \
                iZeroBasedLastListSegmentIndex + 1):

                iZeroBasedDeletionPodcastLogAwsS3ObjectKeysSegmentStartingIndex \
                    = iZeroBasedListSegmentIndex * 1000
                iZeroBasedDeletionPodcastLogAwsS3ObjectKeysSegmentEndingIndex \
                    = (iZeroBasedListSegmentIndex+1)*1000 - 1

                str_listDeletionPodcastLogAwsS3ObjectKeysSegment = \
                    str_listDeletionPodcastLogAwsS3ObjectKeys[ \
                    iZeroBasedDeletionPodcastLogAwsS3ObjectKeysSegmentStartingIndex: \
                    iZeroBasedDeletionPodcastLogAwsS3ObjectKeysSegmentEndingIndex]
                
                try:
                    dictDeleteResponse = s3_bucket.delete_objects(Delete={
                        'Objects': [{'Key': strAwsS3ObjectKey} \
                        for strAwsS3ObjectKey in \
                        str_listDeletionPodcastLogAwsS3ObjectKeysSegment]})
            
                    if self.bIncludeNumbersOfRetriesInPodcastStatsEmails:
                        if 'Deleted' in dictDeleteResponse:
                            print('Deleted objects "%s" from AWS S3 bucket "%s".' \
                                % (str([dictAwsS3Object['Key'] \
                                for dictAwsS3Object in \
                                dictDeleteResponse['Deleted']]), s3_bucket.name))
            
                    if 'Errors' in dictDeleteResponse:
                        print('Error.  Failure to delete objects "%s" from \
AWS S3 bucket "%s".' \
                            % (str([f"{dictAwsS3Object['Key']}: \
{dictAwsS3Object['Code']}" \
                            for dictAwsS3Object in \
                            dictDeleteResponse['Errors']]), s3_bucket.name))
                except botocore.exceptions.ClientError as exc:
                    raise Exception("Error.  Podcast-log AWS S3 objects \
deletion operation generated a client error.\n" \
                        + str(exc))
    
    
    def ReportPodcastStats(self):
        self.dateToday = datetime.date.today()
        self.dateYesterday = self.dateToday - datetime.timedelta(days=1)
        
        #######################################################################
        #Stage 1:  Build the podcast stats
        #######################################################################
        for strPodcastLogAwsS3BucketFolderPath in \
            self.str_listPodcastLogAwsS3BucketFolderPaths:
    
            self._ProcessPodcastLogs(strPodcastLogAwsS3BucketFolderPath)
        
        
        #######################################################################
        #Stage 2:  Email and save the podcast stats
        #######################################################################
        self._EmailAndSavePodcastStats()   
         
        
        #######################################################################
        #Stage 3:  Delete applicable podcast logs
        #######################################################################    
        self._DeletePodcastLogs()
    
    
def lambda_handler(event, context):
    apsr = Aws_Podcast_Stats_Reporter()

    apsr.LoadSettings()
    apsr.ReportPodcastStats()  
    
    return "Success!"


if __name__ == '__main__':
    print("Executing the program in a terminal.")
    
    apsr = Aws_Podcast_Stats_Reporter()
	
    apsr.LoadSettings()
    apsr.ReportPodcastStats()
    
    print("Success!")
    